package amuse;
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.List;

parser code {:
        public void report_error(String message,Object info){
                StringBuffer m=new StringBuffer("Error ");
                if(info instanceof Symbol){
                        Symbol s=((Symbol)info);

                        if(s.left>=0){
                                m.append("en linea "+(s.right+1));
                        if(s.right>=0)
                                m.append(", columna "+(s.left+1));
                        }
                }
                m.append(": "+message);
                System.err.println(m);
        }

        public void report_fatal_error(String message, Object info){
                report_error(message, info);
                System.exit(1);
        }

        public void unrecovered_syntax_error(Symbol cur_token){
                System.out.println(cur_token.toString());
                System.err.println("At line "+(cur_token.right)+", column "+cur_token.left);
                System.exit(1);
        }

        protected void report_expected_token_ids() {
	        List<Integer> ids = expected_token_ids();
	        LinkedList<String> list = new LinkedList<String>();
	        for (Integer expected : ids)
		        list.add(symbl_name_from_id(expected));
                System.err.println("Se esperaba: "+list);
	}
        
:};

action code
{:
:}

/**************
 * Terminales *
 **************/

//If
terminal String ifstart, ifthen, elseclause, elseif, endif;

//Estructura 
terminal String MainProgram, begin, end, parIzq, parDer, cbOpen, cbClose, ret, coma, pcoma;

//Tipos
terminal String booleano, id, voidType;

//Operadores
terminal String opRel, opArit, opOr, opAnd, opNot, opAsig;
terminal opSuma, opResta, opMult, opDiv;
terminal String number;

//Valores
terminal String bool, num, character;

//While                
terminal String whilestart;

//For                
terminal String forstart;

//Select             
terminal String selectstart, breaks, options, colon;

terminal String comment;


/*****************
 * No Terminales *
 *****************/

//Inicial y Expresion
non terminal START, EXP;

//If
non terminal IF, ELSIF, ELSE;

//While
non terminal WHILE;

//For
non terminal FOR;

//Select
non terminal SELECT, OPT;

//Condiciones multipes, negadas o normales
non terminal COND, COND2, COND3, COND4;

//Funcion con retorno
non terminal FUNC, RETFUNC, RETFUNC2, RETFUNCBODY, RETVAL;

//Funcion void
non terminal VOIDFUNC, VOIDFUNC2;

non terminal ARGS, ARGS2, ASIG;

non terminal String VALS, TIPO;

non terminal Integer E,T,F;
non terminal S;

//Operadores
// non terminal Object EXP_ARIT, EXPRresp;
// non terminal Integer EXPS, FACT, TERM;


start with START;





START           ::= MainProgram parIzq parDer cbOpen {: System.out.println("Inicio main");:} EXP cbClose {: System.out.println("Fin main"); :} FUNC;

//No terminal para todas las expresiones que pueden haber. Aqui van ifs, for, switch, while, asignaciones, etc
EXP             ::= IF EXP
                | WHILE EXP
                | ASIG EXP
                | error  EXP
                | comment EXP
                | FOR EXP
                | SELECT EXP
                | S
                | ;

//No terminal que maneja todas las funciones despues del main
FUNC            ::= RETFUNC FUNC
                | VOIDFUNC FUNC
                | error FUNC 
                | ;

//Asignacion / Inicializacion
ASIG            ::= id:i TIPO:t opAsig VALS:v 
                {: System.out.println("\t Inicializacion: Tipo "+t+", id: "+i+", valor: "+v); :}
                |
                id:i opAsig VALS:v
                {: System.out.println("\t Asignacion:  id: "+i+", valor: "+v); :};

//If
IF              ::= {: System.out.println("Inicio IF"); :} 
                ifstart parIzq COND parDer 
                {: System.out.println("\tCondicion if"); :} 
                ifthen EXP ELSIF endif 
                {: System.out.println("Fin if"); :};
ELSIF           ::= elseif parIzq COND parDer 
                {: System.out.println("\tCondicion elseif"); :} ifthen EXP ELSIF 
                | 
                ELSE;
ELSE            ::= elseclause ifthen 
                {: System.out.println("\tElse"); :} EXP 
                | ;

//While
WHILE           ::= {: System.out.println("Inicio WHILE"); :} 
                whilestart parIzq COND parDer 
                {:System.out.println("\tCondicion while");:} 
                EXP end {: System.out.println("fin while"); :};

//For
FOR             ::= {: System.out.println("Inicio FOR"); :}
                forstart parIzq ASIG pcoma COND 
                {:System.out.println("\tCondicion for");:}
                pcoma COND parDer 
                {:System.out.println("\tCondicion for");:}
                EXP 
                end {: System.out.println("fin for"); :};

//Select
SELECT          ::= {: System.out.println("Inicio Select"); :}
                selectstart parIzq id:i parDer
                {:System.out.println("\tVariable:"+i);:}
                OPT
                end 
                {: System.out.println("fin select"); :};

OPT             ::= options VALS:v colon EXP breaks OPT
                {: System.out.println("\t\tOpcion-valor: "+v); :}
                | 
                options VALS:v colon EXP breaks
                {: System.out.println("\t\tOpcion-valor: "+v); :};
        
//Condiciones negadas, normales, con OR o AND
COND            ::= opNot COND2 
                |
                COND2 ;
COND2           ::= id opRel COND3 
                |
                number opRel COND3;
COND3           ::= id COND4 
                | 
                number COND4;
COND4           ::= opOr COND 
                | 
                opAnd COND 
                | ;

// //Expresion Aritmetica
S ::= E:e {: System.out.println("El valor de E: "+e.intValue()); :}
      ;
E ::= E:e opSuma T:t {: RESULT= new Integer(e.intValue()+t.intValue()); :}
      | E:e opResta T:t {: RESULT = new Integer(e.intValue()-t.intValue()); :}
      | T:t{:RESULT = t;:}
      ;
T  ::= T:t opMult F:f {: RESULT = new Integer(t.intValue() * f.intValue());:}
      | T:t opDiv F:f {: RESULT = new Integer(t.intValue() / f.intValue());:}
      | F:f {:RESULT=f;:}
      ;
F ::= number:n {:RESULT = new Integer(n);:}
      |parIzq E:e parDer {:RESULT = e;}
      ;

// EXP_ARIT        ::= EXP_ARIT EXPRresp
//                 |
//                  EXPRresp;
// EXPRresp         ::= EXPS:e
//                 {: System.out.println(" Op =  " + e); :};  

// EXPS            ::= EXPS:e opSuma FACT:f
//                 {:RESULT = new Integer(e.intValue() + f.intValue());:}
//                 |
//                 EXPS:e opResta FACT:f
//                 {:RESULT = new Integer(e.intValue() - f.intValue());:}
//                 |
//                 FACT:n
//                 {:RESULT = n; :}
//                 ;

// FACT            ::= FACT:f opMult TERM:e
//                 {: RESULT = new Integer(f.intValue() * e.intValue()); :}
//                 |
//                 FACT:f opDiv TERM:e
//                 {: RESULT = new Integer(f.intValue() / e.intValue()); :}
//                 |
//                 TERM:t
//                 {:RESULT = t;:};

// TERM            ::=  parIzq expr:e parDer
//                 {: RESULT = e; :}
//                 |
//                 num:e
//                 {: RESULT = e; }; 

//Funcion con retorno
RETFUNC         ::= TIPO {:System.out.println("FUNCTION START");:} RETFUNC2;
RETFUNC2        ::= id parIzq ARGS {:System.out.println("\tArgumentos");:} parDer
                cbOpen {: System.out.println("\tFUNCTION HEADER "); :} RETFUNCBODY cbClose {: System.out.println("FIN FUNCTION");:};
RETFUNCBODY     ::= EXP ret {:System.out.print("\tRETURN - ");:} RETVAL;
RETVAL          ::= VALS:retVal {: System.out.println("Return value: "+retVal); :};

//Funcion void
VOIDFUNC        ::= voidType {:System.out.println("VOID FUNCTION START");:} VOIDFUNC2;
VOIDFUNC2       ::= id parIzq ARGS {:System.out.println("\tArgumentos");:} parDer
                cbOpen {: System.out.println("\tFUNCTION HEADER "); :} EXP cbClose {: System.out.println("FIN FUNCTION");:};


//Argumentos para funciones
ARGS            ::= TIPO id ARGS2 
                | ;
ARGS2           ::=  coma ARGS 
                | ;

//Tipos, falta array
TIPO            ::= bool:val {: RESULT = "bool"; :}
                | 
                num:val {: RESULT = "num"; :}
                | 
                character:val {: RESULT = "char"; :};

//Posibles valores que pueden haber: ids, numeros, booleans, strings/char (estos faltan)
VALS            ::= id:val {: RESULT = val; :}
                | 
                number:val {: RESULT = val; :} 
                | 
                booleano:val {: RESULT = val; :};
                //| comilla letra:val{: System.out.println("val es:"+String.valueOf(val)); RESULT = String.valueOf(val); :} comilla;
