package amuse;
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.List;

parser code
{:
        public void report_error(String message,Object info){
                StringBuffer m=new StringBuffer("Error ");
                if(info instanceof Symbol){
                        Symbol s=((Symbol)info);

                        if(s.left>=0){
                                m.append("en linea "+(s.right+1));
                        if(s.right>=0)
                                m.append(", columna "+(s.left+1));
                        }
                }
                m.append(": "+message);
                System.err.println(m);
        }

        public void report_fatal_error(String message, Object info){
                report_error(message, info);
                System.exit(1);
        }

        public void unrecovered_syntax_error(Symbol cur_token){
                System.out.println(cur_token.toString());
                System.err.println("At line "+(cur_token.right)+", column "+cur_token.left);
                System.exit(1);
        }

        protected void report_expected_token_ids() {
	        List<Integer> ids = expected_token_ids();
	        LinkedList<String> list = new LinkedList<String>();
	        for (Integer expected : ids)
		        list.add(symbl_name_from_id(expected));
                System.err.println("Se esperaba cualquiera de estas: "+list);
	}
        
:}

action code
{:
:}

/**************
 * Terminales *
 **************/

//If
terminal String ifstart, ifthen, elseclause, elseif, endif;

//Estructura 
terminal String MainProgram, begin, end, parIzq, parDer, cbOpen, cbClose, ret, coma;

//Tipos
terminal String booleano, id, number, voidType;

//Operadores
terminal String opRel, opArit, opOr, opAnd, opNot, opAsig;

//Valores
terminal String bool, num, character;

//While                
terminal String whilestart;

terminal String comment;


/*****************
 * No Terminales *
 *****************/

//Inicial y Expresion
non terminal START, EXP;

//If
non terminal IF, ELSIF, ELSE;

//While
non terminal WHILE;

//Condiciones multipes, negadas o normales
non terminal COND, COND2, COND3, COND4;

//Funcion con retorno
non terminal FUNC, RETFUNC, RETFUNC2, RETFUNCBODY, RETVAL;

non terminal ARGS, ARGS2, ASIG;

non terminal String VALS, TIPO;

start with START;

START ::= MainProgram parIzq parDer cbOpen {: System.out.println("Inicio main");:} EXP cbClose {: System.out.println("Fin main"); :} FUNC;

//No terminal para todas las expresiones que pueden haber. Aqui van ifs, for, switch, while, asignaciones, etc
EXP ::= IF EXP
        | WHILE EXP
        | ASIG EXP
        | error  EXP
        | comment EXP
        | ;

//No terminal que maneja todas las funciones despues del main
FUNC ::= RETFUNC FUNC
        | error FUNC
        | ;

//Asignacion
ASIG ::= id:i TIPO:t opAsig VALS:v {: System.out.println("\tAsignacion: Tipo "+t+", id: "+i+", valor: "+v); :};

//If
IF ::= {: System.out.println("Inicio IF"); :} ifstart parIzq COND parDer {: System.out.println("\tCondicion if"); :} ifthen EXP ELSIF endif {: System.out.println("Fin if"); :};

ELSIF ::= elseif parIzq COND parDer {: System.out.println("\tCondicion elseif"); :} ifthen EXP ELSIF 
        | ELSE;
ELSE ::= elseclause ifthen {: System.out.println("\tElse"); :} EXP 
        | ;

//While
WHILE ::= {: System.out.println("Inicio WHILE"); :} whilestart parIzq COND parDer {:System.out.println("\tCondicion while");:} EXP end {: System.out.println("fin while"); :};

//Condiciones negadas, normales, con OR o AND
COND ::= opNot COND2 
        |  COND2 ;
COND2 ::= id opRel COND3 | number opRel COND3;
COND3 ::= id COND4 | number COND4;
COND4 ::= opOr COND 
        | opAnd COND 
        | ;


//Funcion con retorno
RETFUNC ::= TIPO {:System.out.println("FUNCTION START");:} RETFUNC2;
RETFUNC2 ::= id parIzq ARGS {:System.out.println("\tArgumentos");:} parDer
        cbOpen {: System.out.println("\tFUNCTION HEADER "); :} RETFUNCBODY cbClose {: System.out.println("FIN FUNCTION");:};
RETFUNCBODY ::= EXP ret {:System.out.print("\tRETURN - ");:} RETVAL;
RETVAL ::= VALS:retVal {: System.out.println("Return value: "+retVal); :};


//Argumentos para funciones
ARGS ::= TIPO id ARGS2 
        | ;
ARGS2 ::=  coma ARGS 
        | ;

//Tipos, falta array
TIPO ::= bool:val {: RESULT = "bool"; :}| num:val {: RESULT = "num"; :}| character:val {: RESULT = "char"; :};

//Posibles valores que pueden haber: ids, numeros, booleans, strings/char (estos faltan)
VALS ::= id:val {: RESULT = val; :}| number:val {: RESULT = val; :} | booleano:val {: RESULT = val; :};
