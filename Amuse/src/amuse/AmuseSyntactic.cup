package amuse;
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;

parser code {:
        public ArrayList<String> calls = new ArrayList();
        public String arrayValue="";
        public int hayErrores = 0;
        public int contadorNodo = 0;
        public static Nodo padre;
        public TablaSimbolos tabla = new TablaSimbolos();
        public ArrayList<Array> arreglos = new ArrayList();
        public int contadorFunciones = 0;
        public ArrayList<Cuadruplo> cuadruplos = new ArrayList();
        public int contadorTemporales=0;
         
        public void gen(String op, String arg1, String arg2, String res){
                cuadruplos.add(new Cuadruplo(op, arg1, arg2, res));
        }

        public void gen(String op, String res){
                cuadruplos.add(new Cuadruplo(op, res));
        }

        public void printCuadruplos(){
                System.out.println("CUADRUPLOS:");
                for(int i = 0; i < cuadruplos.size(); i++){
                        System.out.println(i+" - "+cuadruplos.get(i).toString());
                }
        }

        public ArrayList<Integer> fusiona (ArrayList<Integer> l1, ArrayList<Integer> l2){
                ArrayList<Integer> retVal = new ArrayList();
                retVal.addAll(l1);
                for(Integer i : l2){
                        if(!retVal.contains(i)){
                                retVal.add(i);
                        }

                }
                return retVal; 
        }

        public void completa(ArrayList<Integer> lista, int cuad){
                for(Integer i: lista){
                        cuadruplos.get(i.intValue()).setResult(cuad+"");
                }
        }

        public String nuevoTemp(){
                return "t"+contadorTemporales;
        }

        public void report_error(String message,Object info){
                StringBuffer m=new StringBuffer("Error ");
                if(info instanceof Symbol){
                        Symbol s=((Symbol)info);

                        if(s.left>=0){
                                m.append("en linea "+(s.left+1));
                                if(s.right>=0)
                                        m.append(", columna "+(s.right+1));
                        }
                }
                m.append(": "+message);
                System.err.println(m);
                hayErrores = 1;
        }

        public void report_fatal_error(String message, Object info){
                report_error(message, info);
                hayErrores = 1;
                // System.exit(1);
        }

        public void unrecovered_syntax_error(Symbol cur_token){
                System.out.println(cur_token.toString());
                System.err.println("At line "+(cur_token.left)+", column "+cur_token.right);
                hayErrores = 1;
                // System.exit(1);
        }

        protected void report_expected_token_ids() {
                hayErrores = 1;
	        List<Integer> ids = expected_token_ids();
	        LinkedList<String> list = new LinkedList<String>();
	        for (Integer expected : ids)
		        list.add(symbl_name_from_id(expected));
                // System.err.println("Se esperaba: "+list);
	}

        public String operationValidation(Value e){
                try {
                        int p = e.tipo.indexOf("->");
                        boolean errores= false;
                        if(p>=0){
                                if(functionType(e, p).equals("num")){
                                        return 0+"";
                                }else{
                                        return "error";
                                }
                        }else{
                                Integer.parseInt(e.val);
                                return e.val;                                                        
                        }                                                                           
                } catch (NumberFormatException o) {
                        return "error";
                }
                
        }

        public String functionType(Value e, int indexReturn){
                if((e.tipo.substring(indexReturn+2).equals("num"))){
                        return "num";
                }else{
                        return "error";
                }
        }

        public void printError(int linea, int columna, String val1, String val2, String tipo){
                switch (tipo) {
                        case "DetailVariable":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t"+val2+" "+val1);
                                break;
                        case "notfound":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t Variable no declarada asignada a "+val1);
                                break;
                        case "out of bounds":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t Indice "+val2+" fuera de alcance del arreglo");
                                break;
                        case "incompatible":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t Asignacion de variable "+val1+" con operacion aritmetica con tipos incompatibles");
                                break;
                        case "tipos":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t Asignacion de "+val1+" a variable de tipo "+val2);
                                break;
                        case "notDeclared":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t La variable "+val1+" no ha sido declarada");
                                break;
                        case "declared":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t La variable "+val1+" ya fue declarada");
                                break;
                        default: 
                                break;
                }
        }


        
:};

action code
{:
:}

/**************
 * Terminales *
 **************/

//If
terminal String ifstart, ifthen, elseclause, elseif, endif;

//Estructura 
terminal String MainProgram, end, parIzq, parDer, cbOpen, cbClose, ret, coma, pcoma, openBrk, closeBrk;

//Tipos
terminal String booleano, id, voidType, character;

//Operadores
terminal String opRel, opOr, opAnd, opNot, opAsig;
terminal opSuma, opResta, opMult, opDiv;
terminal String number;




//Valores
terminal String bool, num, charval;

//While                
terminal String whilestart;

//For                
terminal String forstart, contador;

//Write                
terminal String writestart;

//Select             
terminal String selectstart, breaks, options, colon;

terminal String comment;



/*****************
 * No Terminales *
 *****************/

//Inicial y Expresion
non terminal Expresion LISTEXP;
non terminal Expresion START, EXP;
non terminal Expresion N;
non terminal Integer M;


//If
non terminal Expresion IF, ELSIF, ELSE;

//While
non terminal Expresion WHILE;

//For
non terminal Expresion FOR, CONTADOR;

//Write
non terminal WRITE;

//Select
non terminal SELECT, OPT, OPT2;

//Condiciones multipes, negadas o normales
non terminal Expresion COND, COND2;

//Headers de funciones
non terminal FUNC_HEAD;
non terminal String TYPE_LIST, TYPE_LIST2;

//Funcion con retorno
non terminal FUNC, RETFUNC, RETVAL;
non terminal String RETFUNCBODY;
//Funcion void
non terminal VOIDFUNC;

non terminal String ARGS, ARGS2; 
non terminal ASIG, ARRVAL1, ARRVAL2, ARRVAL3;
non terminal Integer ASIG2;
non terminal String INIT, DECL;
non terminal String ARRVAL0;
non terminal String TIPO;
non terminal Value VALS;

non terminal Value F, E, T, S;

non terminal Value IdF;
non terminal Integer TypeIdF;
non terminal FCALLARGS, FCALLARGS2;
//Operadores
// non terminal Object EXP_ARIT, EXPRresp;
// non terminal Integer EXPS, FACT, TERM;
precedence left opOr, opAnd;
precedence left opSuma, opResta;
precedence left opMult, opDiv;
precedence left opAsig;

start with START;

START           ::= FUNC_HEAD MainProgram parIzq parDer cbOpen {: System.out.println("Inicio main");:} LISTEXP cbClose {: 
                                System.out.println("Fin main");
                                tabla.disableVars(contadorFunciones);
                                printCuadruplos();
                                System.out.println(tabla.toString()); 
                        :} 
                    FUNC;

//No terminal para todas las expresiones que pueden haber. Aqui van ifs, for, switch, while, asignaciones, etc
LISTEXP ::= EXP:exp M:m 
                {: 
                        completa(exp.listasig, m.intValue()); 
                :} 
                LISTEXP:lexp 
                {: 
                        RESULT = new Expresion(); 
                        RESULT.listasig = lexp.listasig;
                :}
        | EXP:exp M:m 
                {: 
                
                        // RESULT = new Expresion(); 
                        // RESULT.listasig = ifexp.listasig; 
                        completa(exp.listasig, m.intValue());
                        RESULT = new Expresion(); :};

EXP             ::= error {: RESULT = new Expresion(); :}
                | 
                IF:ifexp 
                        {: 
                                RESULT = new Expresion(); 
                                RESULT.listasig = ifexp.listasig; 
                        :}  
                | 
                WHILE:whileexp  
                        {:
                                RESULT = new Expresion(); 
                                RESULT.listasig = whileexp.listasig;
                        :}
                | 
                ASIG    {: RESULT = new Expresion(); :}
                | 
                comment {: RESULT = new Expresion(); :}
                | 
                INIT    {: RESULT = new Expresion(); :}
                | 
                DECL    {: RESULT = new Expresion(); :}
                | 
                FOR:forexp  
                        {: 
                                RESULT = new Expresion();
                                RESULT.listasig = forexp.listasig;
                        :}
                | 
                SELECT  {: :}
                | 
                IdF:val {: :}
                | 
                WRITE 
                ;


IdF ::= id:ident TypeIdF:val {:    
                                int index = tabla.contains(ident);
                                if(val == -3){
                                        int resultado = 0;
                                        if(index>=0){
                                                Simbolo sym = tabla.getSymbol(ident);
                                                RESULT = sym.valor;
                                        }else{
                                                RESULT = new Value("error", "notfound");
                                        }
                                }else if(val == -2){
                                        calls.add(ident);
                                        if(index >= 0) {
                                                Simbolo sym = tabla.getSymbol(ident);
                                                RESULT = new Value(sym.tipo, sym.id);
                                        }else{
                                                RESULT = new Value("error", "notfound");
                                        }
                                }else {
                                        int ind = tabla.getIndexVal(ident);
                                        if(index >= 0) {
                                                if(val>=0 && val<=arreglos.get(ind).fin){
                                                        RESULT = arreglos.get(ind).getValue(val);
                                                }else{ 
                                                        RESULT = new Value("error", "out of bounds");
                                                }
                                        }else{
                                                RESULT = new Value("error", "notfound");
                                        }
                                        
                                }
                        :};

TypeIdF ::= 
        openBrk number:n closeBrk      
                                        {: 
                                                if(Integer.parseInt(n)>=0){
                                                        RESULT = Integer.parseInt(n); 
                                                }else{
                                                        RESULT = -1; 
                                                }

                                        :}
        |
        parIzq FCALLARGS parDer         {: RESULT = -2; :}
        |
                                        {: RESULT = -3; :};

FCALLARGS ::= VALS:arg FCALLARGS2 | ;
FCALLARGS2 ::= coma VALS:arg FCALLARGS2 | ; 

//No terminal que maneja todas las funciones despues del main
FUNC            ::= RETFUNC FUNC
                | VOIDFUNC FUNC
                | ;

FUNC_HEAD       ::= TIPO:fun_type id:fun_name parIzq TYPE_LIST:args parDer {:
                        int index = tabla.contains(fun_name);
                        if(index == -1){
                                tabla.addVar(args+"->"+fun_type, fun_name, null);
                                contadorFunciones++;
                        }else{
                                printError(fun_nameleft,fun_nameright,fun_name, "Ya existe la función","DetailVariable");
                        }
                :} FUNC_HEAD 
                | voidType id:fun_name parIzq TYPE_LIST:args parDer {:
                        int index = tabla.contains(fun_name);
                        if(index == -1){
                                tabla.addVar(args+"->void", fun_name, null);
                                contadorFunciones++;
                        }else{
                                printError(fun_nameleft,fun_nameright,fun_name, "Ya existe la función","DetailVariable");
                        }
                :} FUNC_HEAD
                |;
TYPE_LIST       ::= TIPO:tipo TYPE_LIST2:tl {: RESULT = tipo + tl; :} | ;
TYPE_LIST2      ::= coma TIPO:tipo TYPE_LIST2:tl {: RESULT = "x"+tipo+tl; :} | {: RESULT = ""; :};

//Asignacion / Inicializacion
DECL            ::=id:i TIPO:t ASIG2:asig2
                {:
                        int index = tabla.contains(i);
                        System.out.println("Asignacion: ID: "+i+", index: "+index);
                        if(index == -1){
                                Value v = new Value("","");
                                tabla.addVar(t, i, v);
                                System.out.println("\tInicializacion: id: "+i+", tipo: "+t);
                                RESULT = i;
                        }else{
                                RESULT = "";
                                printError(tleft,tright,i,"","declared");
                        } 
                :};

INIT            ::= id:i TIPO:t opAsig VALS:v {:
                        int index = tabla.contains(i);
                        System.out.println("Asignacion: ID: "+i+", index: "+index);
                        if(index == -1){
                                //si no existe la variable revisa si el valor tiene error
                                if(v.tipo.equals("error")){
                                        printError(vleft,vright,i,"",v.val);
                                }else{
                                        int ind = t.indexOf("array");
                                        if(ind!=-1){
                                                String tipo = t.substring(0,ind-1);
                                                if(v.tipo.equals("array")){
                                                        // que sea asignado a un conjunto de elementos entre corchetes("array")
                                                        // Cuando es array el contenido de VALS = Value(tipo->"array", val->"{5,6,7}")
                                                        // Cuando es array el contenido de TIPO = "num array"
                                                        try{
                                                                String[] contenido = v.val.split(",");
                                                                Array m = new Array(0,contenido.length-1,tipo);
                                                                int cont = 0;
                                                                if(tipo.equals("num")){
                                                                        for(int j= contenido.length-1 ; 0 <= j; j--){
                                                                                m.addInt(cont,Integer.parseInt(contenido[j]));
                                                                                cont++;
                                                                        }
                                                                }else if(tipo.equals("char")){
                                                                        for(int j= contenido.length-1 ; 0 <= j; j--){
                                                                                m.addChar(cont,contenido[j].charAt(1));
                                                                                cont++;
                                                                        }
                                                                }else if(tipo.equals("bool")){
                                                                        for(int j= contenido.length-1 ; 0 <= j; j--){
                                                                                if(contenido[j].equals("true") || contenido[j].equals("false")){
                                                                                        m.addBool(cont,contenido[j]);
                                                                                }
                                                                                m.addBool(cont,contenido[j]);
                                                                                cont++;
                                                                        }
                                                                }
                                                                v.setVal(arreglos.size()+"");
                                                                arreglos.add(m);
                                                                tabla.addVar(t, i, v);
                                                        }catch(Exception e){
                                                                printError(vleft,vright,i,"Tipos incompatibles en "+tipo,"DetailVariable");
                                                        }
                                                }else{
                                                        printError((vleft+1),vright,v.tipo,t,"tipos");
                                                }
                                        }else{
                                                if(v.tipo.equals(t)){
                                                        tabla.addVar(t, i, v);
                                                        gen(":=", v.val, "", i);
                                                        System.out.println("\tInicializacion: id: "+i+", tipo: "+t+", valor: "+v.val);
                                                        RESULT = i;
                                                }else{
                                                        RESULT = "";
                                                        printError((vleft+1),vright,v.tipo,t,"tipos");
                                                }
                                        }
                                }
                        }else{
                                RESULT = "";
                                printError(vleft,vright,i,"","declared");
                        }
                :};


ASIG            ::= id:i ASIG2:asig2 opAsig VALS:v {: 
                        int index = tabla.contains(i);
                        if(index>=0){
                                if(v.tipo.equals("error")){
                                        printError(vleft+1,vright,i,"",v.val);
                                }else{ 
                                        if(asig2 == -1){
                                                Simbolo sym = tabla.getSymbol(i);
                                                if(v.tipo.equals(sym.tipo)){
                                                        tabla.assignValue(index, v);
                                                        gen(":=", v.val, "", sym.id);
                                                        if(v.tipo.equals("boolean")){
                                                                System.out.println("Asignacion: Variable "+i+", valor: "+v.getBoolVal());
                                                        }else if(v.tipo.equals("num")){
                                                                System.out.println("Asignacion: Variable "+i+", valor: "+v.getIntVal());
                                                        }else if(v.tipo.equals("char")){
                                                                System.out.println("Asignacion: Variable "+i+", valor: "+v.getCharVal());
                                                        }
                                                }else{ 
                                                        printError((vleft+1), vright, v.tipo, sym.tipo,"tipos");
                                                }
                                        }else{
                                                //Cuando esta aqui la unica validacion que necesita es que el valor singular del array sea igualado a otro del mismo
                                                int arrayIndex;
                                                arrayIndex = tabla.getIndexVal(i);
                                                System.out.println("HEEEEY-> Indice del array "+asig2+" Bounds [0, "+arreglos.get(arrayIndex).fin+"] ");
                                                if(asig2>=0 && asig2<=arreglos.get(arrayIndex).fin){
                                                        if(v.tipo.equals(arreglos.get(arrayIndex).tipo) && arrayIndex>0){
                                                                arreglos.get(arrayIndex).assignValue(asig2,v.val);
                                                        }else{
                                                                printError((vleft+1),vright,v.tipo,arreglos.get(arrayIndex).tipo,"tipos");
                                                        }
                                                }else{ 
                                                        printError(vleft+1, vright, i, asig2+"", "out of bounds");
                                                }
                                        }
                                }
                        }else{
                                printError(vleft,vright,i,"","notDeclared");
                        }
                :};

ASIG2           ::= openBrk number:n closeBrk 
                {: RESULT = Integer.parseInt(n); :}
                |
                {: RESULT = -1; :};

//If
IF              ::= {: System.out.println("Inicio IF"); :} 
                ifstart parIzq COND:cond parDer 
                ifthen M:m1 LISTEXP:exp N:n M:m2 ELSIF:elsif M:m3 ELSE:elsecase endif 
                {:
                        completa(cond.listav, m1.intValue());
                        RESULT = new Expresion();
                        if(elsif == null && elsecase == null){ 
                                RESULT.listasig = fusiona(cond.listaf, fusiona(n.listasig, exp.listasig));
                        }else if(elsif == null && elsecase != null){              
                                completa(cond.listaf, m3.intValue());
                                RESULT.listasig = fusiona(elsecase.listasig, n.listasig);
                        }else if(elsif != null && elsecase == null){
                                completa(cond.listaf, m2.intValue());
                                RESULT.listasig = fusiona(elsif.listasig, n.listasig);
                        }else if(elsif != null && elsecase != null){
                                System.out.println("ENTRO A ULTIMO CASO");
                                completa(cond.listaf, m2.intValue());
                                System.out.println("ELSIF LISTASIG");
                                for(Integer ceils : elsif.listasig){
                                        System.out.println(ceils.intValue());
                                }
                                ArrayList<Integer> tempLista = new ArrayList();
                                tempLista.add(elsif.listasig.get(0));
                                completa(tempLista, m3.intValue());
                                elsif.listasig.remove(0);
                                RESULT.listasig = fusiona(elsecase.listasig, fusiona(elsif.listasig, n.listasig));
                        }
                :};
               
ELSIF           ::= elseif parIzq COND:cond parDer ifthen M:m1 LISTEXP:exp N:n M:m2 ELSIF:elseifcase
                {:
                        completa(cond.listav, m1.intValue());
                        RESULT = new Expresion();
                        if(elseifcase !=null){
                                completa(cond.listaf, m2.intValue());
                                RESULT.listasig = fusiona(elseifcase.listasig, fusiona(exp.listasig, n.listasig));
                        }else{
                                RESULT.listasig = fusiona(exp.listasig, fusiona(cond.listaf, n.listasig));
                        }
                :}
                | {: RESULT = null; :};

ELSE            ::= elseclause ifthen LISTEXP:exp
                        {:
                                RESULT = new Expresion();
                                RESULT.listasig = exp.listasig;
                        :}
                | {: RESULT = null; :};

//While
WHILE           ::= 
                whilestart M:m1 parIzq COND:cond parDer M:m2 LISTEXP:exp N:n end 
                        {: 
                                completa(cond.listav, m2.intValue());
                                completa(fusiona(exp.listasig, n.listasig), m1.intValue());
                                RESULT = new Expresion();
                                RESULT.listasig = cond.listaf;
                        :};
//Write
WRITE           ::= writestart parIzq VALS:val parDer 
                {:System.out.println("\tWRITE Valor:"+val);:};

//For
FOR             ::= 
                forstart 
                parIzq 
                INIT:id pcoma 
                M:m1 COND:cond pcoma 
                M:m2 CONTADOR N:n1
                parDer
                M:m3 LISTEXP:exp N:n2
                end {: 
                        completa(n1.listasig, m1.intValue());
                        completa(n2.listasig, m2.intValue());
                        completa(cond.listav, m3.intValue());
                        RESULT = new Expresion();
                        RESULT.listasig = cond.listaf;
                        tabla.removeVar(id);  
                        //System.out.println("TABLA SIMBOLOS DESPUES DE FOR: "+tabla.toString()); 
                :};

CONTADOR        ::= 
                id:i contador:cont {: gen("+", "1", "", i); :}; 

//Select
SELECT          ::= {: System.out.println("Inicio Select"); :}
                selectstart parIzq id:i parDer
                {:System.out.println("\tVariable:"+i);:}
                OPT
                end 
                {: System.out.println("fin select"); :};

OPT             ::= options VALS:v {: System.out.println("\t\tOpcion-valor: "+v); :} colon EXP breaks OPT2;
OPT2            ::= OPT | ;
        
//Condiciones negadas, normales, con OR o AND
// COND            ::= opNot COND2 
//                 |
//                 COND2 ;
// COND2           ::= id opRel COND3 
//                 | booleano
//                 |
//                 number opRel COND3;
// COND3           ::= id COND4 
//                 | booleano COND4
//                 |
//                 number COND4;
// COND4           ::= opOr COND 
//                 | 
//                 opAnd COND 
//                 | ;

COND ::= 
        parIzq COND:cond parDer 
                {: 
                        RESULT = new Expresion();
                        RESULT.listav = cond.listav;
                        RESULT.listaf = cond.listaf;
                :} COND2

        | opNot COND:c 
                {:
                        RESULT = new Expresion(); 
                        RESULT.listav = c.listaf; 
                        RESULT.listaf = c.listav; 
                :} 
                COND2

        | id:i1 opRel:opr id:i2 
                {:      
                        RESULT = new Expresion();
                        RESULT.listav.add(cuadruplos.size());
                        RESULT.listaf.add(cuadruplos.size()+1);
                        gen("IF"+opr, i1, i2, "");
                        gen("GOTO", "");
                        
                :} 
                COND2:cond2 
                {:
                        int index_id1 = tabla.contains(i1);
                        int index_id2 = tabla.contains(i2);
                        if(index_id1 > -1 && index_id2 > -1){
                                
                                if(cond2 != null){
                                        Expresion temp = RESULT;
                                        if(cond2.or){
                                                completa(temp.listaf, cond2.cuad);
                                                RESULT = new Expresion();
                                                System.out.println("Listas a fusionar:\ntemp.listav\n-----------");
                                                
                                                for(Integer ctlv : temp.listav){
                                                        System.out.println(ctlv.intValue());
                                                }
                                                System.out.println("cond2.listav\n-----------");
                                                
                                                for(Integer cclv : cond2.listav){
                                                        System.out.println(cclv.intValue());
                                                }

                                                ArrayList<Integer> lvfusion = fusiona(temp.listav, cond2.listav);
                                                System.out.println("Lista fusionada:\n-----------");
                                                
                                                for(Integer clvf : lvfusion){
                                                        System.out.println(clvf.intValue());
                                                }

                                                RESULT.listav = fusiona(temp.listav, cond2.listav);
                                                RESULT.listaf = cond2.listaf;

                                                System.out.println("Lista Falsa:\n------------");
                                                for(Integer crlf : RESULT.listaf){
                                                        System.out.println(crlf.intValue());
                                                }
                                        }else{
                                                completa(temp.listav, cond2.cuad);
                                                RESULT = new Expresion();
                                                RESULT.listaf = fusiona(temp.listaf, cond2.listaf);
                                                RESULT.listav = cond2.listav;
                                        }
                                }
                        }else{
                                //error var(s) no encontrada(s)
                        }
                :}

        | booleano:boolval 
                {: 
                        RESULT = new Expresion();
                        if(boolval.equals("true")){ 
                                RESULT.listav.add(cuadruplos.size()); 
                        }else{
                                RESULT.listaf.add(cuadruplos.size());
                        }
                        gen("GOTO", "");
                :} 
                COND2;

COND2 ::= opOr {: System.out.println("operador OR"); :} 
          M:m 
          COND:cond
          {:
                RESULT = new Expresion(true);
                RESULT.cuad = m.intValue();
                RESULT.listav = cond.listav;
                RESULT.listaf = cond.listaf;
                
          :}
        | 
          opAnd {: System.out.println("operador AND"); :} 
          M:m 
          COND:cond 
          {:
                RESULT = new Expresion(false);
                RESULT.cuad = m.intValue();
                RESULT.listav = cond.listav;
                RESULT.listaf = cond.listaf;
                
          :}
        | {: RESULT = null; System.out.println(""); :};

M ::= {: RESULT = new Integer(cuadruplos.size()); :} ;

N ::= 
        {:
                RESULT = new Expresion();
                RESULT.listasig.add(cuadruplos.size());
                gen("GOTO", "");
        :};

// //Expresion Aritmetica
S               ::= E:e                 {: RESULT = e;:};

E               ::= E:e opSuma T:t      {: 
                                                if(e.tipo.equals("error") || t.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(e), y = operationValidation(t);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible");
                                                        }else{
                                                                gen("+", e.val, t.val, nuevoTemp());
                                                                RESULT = new Value("num", (Integer.parseInt(x) + Integer.parseInt(y))+"");
                                                        }
                                                }
                                        :}
                | 
                E:e opResta T:t         {: 
                                                if(e.tipo.equals("error") || t.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(e), y = operationValidation(t);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible");
                                                        }else{
                                                                //gen("-", e.val, t.val, nuevoTemp());
                                                                RESULT = new Value("num", (Integer.parseInt(x) - Integer.parseInt(y))+"");
                                                        }
                                                }                                                 
                                        :}
                | 
                T:t                     {:RESULT = t;:};

T               ::= T:t opMult F:f      {: 
                                                if(t.tipo.equals("error") || f.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(t), y = operationValidation(f);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible");
                                                        }else{
                                                                gen("*", t.val, f.val, nuevoTemp());
                                                                RESULT = new Value("num", (Integer.parseInt(x) * Integer.parseInt(y))+"");
                                                        }
                                                }  
                                        :}
                | 
                T:t opDiv F:f           {: 
                                                if(t.tipo.equals("error") || f.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(t), y = operationValidation(f);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible");
                                                        }else{
                                                                gen("/", t.val, f.val, nuevoTemp());
                                                                RESULT = new Value("num", (Integer.parseInt(x) / Integer.parseInt(y))+"");
                                                        }
                                                }  
                                        :}
                | 
                F:f                     {: RESULT=f; :};
                
F               ::=
                number:n                {: RESULT = new Value("num", n); :}
                |
                parIzq E:e parDer       {: RESULT = e; :}
                |
                IdF:val                 {: RESULT = val; :}
                ;


//Funcion con retorno
RETFUNC         ::= TIPO:t id:val {: calls.clear(); :} parIzq ARGS:args parDer
                cbOpen RETFUNCBODY {:
                        // boolean rec = false;
                        // for(int i = 0; i < calls.size(); i++){
                        //         if(calls.get(i).equals(val)){
                        //                 rec = true;
                        //                 break;
                        //         }
                        // }
                        // if(rec){
                        //         System.out.println("La funcion "+val+" es recursiva");
                        // }
                        int index = tabla.contains(val);
                        if(index >= 0){
                                Simbolo funcion = tabla.getSymbol(val);
                                if(funcion.tipo.equals(args+"->"+t)){
                                        System.out.println("Funcion "+val+", tipo: "+args+"->"+t);
                                }else{
                                        printError(argsleft, argsright, (args+"->"+t), "Funcion "+val+" de tipo "+funcion.tipo+" ha sido utilizada como ","DetailVariable");
                                }
                        }else{
                                printError(valleft, valright, val, "No ha sido declarada la función ","DetailVariable");
                        }
                :} cbClose 
                ;
RETFUNCBODY     ::= EXP:exp ret RETVAL;
RETVAL          ::= VALS:retVal ;

//Funcion void
VOIDFUNC        ::= voidType id:val {:System.out.println("VOID FUNCTION "+val+" START"); calls.clear(); :} parIzq ARGS:args parDer
                cbOpen EXP {: 
                        // boolean rec = false;
                        // for(int i = 0; i < calls.size(); i++){
                        //         if(calls.get(i).equals(val)){
                        //                 rec = true;
                        //                 break;
                        //         }
                        // }
                        // if(rec){
                        //         System.out.println("La funcion "+val+" es recursiva");
                        // }
                        int index = tabla.contains(val);
                        if(index >= 0){
                                Simbolo funcion = tabla.getSymbol(val);
                                if(funcion.tipo.equals(args+"->void")){
                                        System.out.println("FIN FUNCTION");
                                }else{
                                        printError(argsleft, argsright, funcion.tipo, "Error en funcion de tipo "+args+"->VOID como ","DetailVariable");
                                }
                        }else{
                                printError(valleft, valright, val, "Funcion no declarada ","DetailVariable");
                        }
                :} cbClose ;


//Argumentos para funciones
ARGS            ::= TIPO:t id:i ARGS2:arg2       {: RESULT = t+arg2; :} 
                | ;
ARGS2           ::=  coma TIPO:t id:i ARGS2:arg2 {: RESULT = "x"+t+arg2; :}
        |                                        {: RESULT = ""; :};

//Tipos, falta array
TIPO            ::=
                TIPO:t openBrk closeBrk {: RESULT = t+" array"; :}
                |
                bool:val                {: RESULT = "bool"; :}
                |
                num:val                 {: RESULT = "num"; :}
                | 
                character:val           {: RESULT = "char"; :}
                ;

//Posibles valores que pueden haber: ids, numeros, booleans, strings/char (estos faltan)
VALS            ::=
                booleano:val    {: RESULT = new Value("bool", val); :}
                |
                charval:ch      {: RESULT = new Value("char", ch.charAt(1)+""); :}
                |
                S:val           {: RESULT = val; :}
                |
                ARRVAL0:val      {: RESULT = new Value("array", val); :}
                ;

//Valores para array
ARRVAL0          ::= cbOpen S:v ARRVAL2 cbClose 
                        {: 
                                arrayValue += v.val + "";
                                RESULT = arrayValue; 
                                arrayValue = ""; 
                        :}
                |cbOpen booleano:v ARRVAL2 cbClose 
                        {: 
                                arrayValue += v + "";
                                RESULT = arrayValue; 
                                arrayValue = ""; 
                        :}
                |cbOpen charval:v ARRVAL2 cbClose 
                        {: 
                                arrayValue += v + "";
                                RESULT = arrayValue; 
                                arrayValue = ""; 
                        :};        


ARRVAL2         ::= coma ARRVAL3:v
                |;

ARRVAL3         ::= S:v ARRVAL2       
                                        {:   
                                                arrayValue += (v.val+",");
                                        :}
                |booleano:v ARRVAL2   
                                        {:   
                                                arrayValue += (v+","); 
                                        :}
                |charval:v ARRVAL2    
                                        {:   
                                                arrayValue += (v+",");
                                        :};