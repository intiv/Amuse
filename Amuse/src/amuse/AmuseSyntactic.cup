package amuse;
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;

parser code {:
        public ArrayList<String> calls = new ArrayList();
        public String arrayValue="";
        public int hayErrores = 0;
        public int contadorNodo = 0;
        public static Nodo padre;
        public TablaSimbolos tabla = new TablaSimbolos();
        public ArrayList<Array> arreglos = new ArrayList();
        public int contadorFunciones = 0;
        public ArrayList<Cuadruplo> cuadruplos = new ArrayList();
        public int contadorTemporales=0;
        public String currAmbito = "";
        public boolean hasReturn = false;
        public int offset = 0;
        public int contArgs = 0;

        public void gen(String op, String arg1, String arg2, String res){
                cuadruplos.add(new Cuadruplo(op, arg1, arg2, res));
        }

        public void gen(String op, String res){
                cuadruplos.add(new Cuadruplo(op, res));
        }

        public void printCuadruplos(){
                System.out.println("CUADRUPLOS:");
                for(int i = 0; i < cuadruplos.size(); i++){
                        System.out.println(i+" - "+cuadruplos.get(i).toString());
                }
        }

        public ArrayList<Integer> fusiona (ArrayList<Integer> l1, ArrayList<Integer> l2){
                ArrayList<Integer> retVal = new ArrayList();
                retVal.addAll(l1);
                for(Integer i : l2){
                        if(!retVal.contains(i)){
                                retVal.add(i);
                        }
                }
                return retVal; 
        }

        public void completa(ArrayList<Integer> lista, int cuad){
                for(Integer i: lista){
                        cuadruplos.get(i.intValue()).setResult(cuad+"");
                }
        }

        public void completaArg1(ArrayList<Integer> lista, String id){
                for(Integer i: lista){
                        cuadruplos.get(i.intValue()).setArg1(id+"");
                }
        }

        public String nuevoTemp(){
                String tempRet = "t"+contadorTemporales;
                contadorTemporales++;
                return tempRet;
        }

        public void report_error(String message,Object info){
                StringBuffer m=new StringBuffer("Error ");
                if(info instanceof Symbol){
                        Symbol s=((Symbol)info);

                        if(s.left>=0){
                                m.append("en linea "+(s.left+1));
                                if(s.right>=0)
                                        m.append(", columna "+(s.right+1));
                        }
                }
                m.append(": "+message);
                System.err.println(m);
                hayErrores = 1;
        }

        public void report_fatal_error(String message, Object info){
                report_error(message, info);
                hayErrores = 1;
                // System.exit(1);
        }

        public void unrecovered_syntax_error(Symbol cur_token){
                System.out.println(cur_token.toString());
                System.err.println("At line "+(cur_token.left)+", column "+cur_token.right);
                hayErrores = 1;
                // System.exit(1);
        }

        protected void report_expected_token_ids() {
                hayErrores = 1;
	        List<Integer> ids = expected_token_ids();
	        LinkedList<String> list = new LinkedList<String>();
	        for (Integer expected : ids)
		        list.add(symbl_name_from_id(expected));
                // System.err.println("Se esperaba: "+list);
	}

        public String operationValidation(Value e){
                int p = e.tipo.indexOf("->");
                boolean errores= false;
                if(p>=0){
                        if(functionType(e, p).equals("num")){
                                return 0+"";
                        }
                }else{
                        if(e.tipo.equals("num")){
                                return e.val; 
                        }                                                     
                }
                return "error";
        }

        public String functionType(Value e, int indexReturn){
                if((e.tipo.substring(indexReturn+2).equals("num"))){
                        return "num";
                }else{
                        return "error";
                }
        }

        public boolean isID(Value value){
                if(value.val.length() == 3 && value.val.charAt(0) == '\'' && value.val.charAt(2) == '\''){
                        return false;
                }else if(value.val.matches("\\d+")){
                        return false;
                }else if(value.val.equals("true") || value.val.equals("false")){
                        return false;
                }

                return true;
        }

        public void printError(int linea, int columna, String val1, String val2, String tipo){
                switch (tipo) {
                        case "DetailVariable":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t"+val2+" "+val1);
                                break;
                        case "notfound":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t Variable no declarada asignada a "+val1);
                                break;
                        case "out of bounds":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t Indice "+val2+" fuera de alcance del arreglo");
                                break;
                        case "incompatible":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t Asignacion de variable "+val1+" con operacion aritmetica con tipos incompatibles");
                                break;
                        case "tipos":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t Asignacion de "+val1+" a variable de tipo "+val2);
                                break;
                        case "notDeclared":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t La variable "+val1+" no ha sido declarada");
                                break;
                        case "declared":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t La variable "+val1+" ya fue declarada");
                                break;
                        case "blankCall":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t Expresion incompleta");
                                break;
                        case "notInitialized":
                                System.err.println("Error en linea "+linea+", columna "+columna+":\t Uso de variable no inicializada");
                                break;
                        default:
                                System.err.println("Error en linea "+linea+", columna "+columna); 
                                break;
                }
        }


        
:};

action code
{:
:}

/**************
 * Terminales *
 **************/

//If
terminal String ifstart, ifthen, elseclause, elseif, endif;

//Estructura 
terminal String MainProgram, end, parIzq, parDer, cbOpen, cbClose, ret, coma, pcoma, openBrk, closeBrk;

//Tipos
terminal String booleano, id, voidType, character;

//Operadores
terminal String opRel, opOr, opAnd, opNot, opAsig;
terminal opSuma, opResta, opMult, opDiv;
terminal String number;




//Valores
terminal String bool, num, charval;

//While                
terminal String whilestart;

//For                
terminal String forstart, contador;

//Write                
terminal String writestart;

//Select             
terminal String selectstart, breaks, options, colon;

terminal String comment;



/*****************
 * No Terminales *
 *****************/

//Inicial y Expresion
non terminal Expresion LISTEXP;
non terminal Expresion START, EXP;
non terminal Expresion N;
non terminal Integer M;


//If
non terminal Expresion IF, ELSIF, ELSE;

//While
non terminal Expresion WHILE;

//For
non terminal Expresion FOR, CONTADOR;

//Write
non terminal WRITE;

//Select
non terminal Expresion SELECT, OPT, OPT2;

//Condiciones multipes, negadas o normales
non terminal Expresion COND, COND2;

//Headers de funciones
non terminal FUNC_HEAD;
non terminal String TYPE_LIST, TYPE_LIST2;

//Funcion con retorno
non terminal FUNC, RETFUNC, RETVAL;
non terminal String RETFUNCBODY;
//Funcion void
non terminal VOIDFUNC;

non terminal Parametros ARGS, ARGS2; 
non terminal ASIG, ARRVAL1, ARRVAL2, ARRVAL3;
non terminal Integer ASIG2;
non terminal String INIT, DECL;
non terminal String ARRVAL0;
non terminal String TIPO;
non terminal Value VALS;

non terminal Value F, E, T, S;

non terminal Value IdF;
non terminal Integer TypeIdF;
non terminal FCALLARGS, FCALLARGS2;
//Operadores
// non terminal Object EXP_ARIT, EXPRresp;
// non terminal Integer EXPS, FACT, TERM;
precedence left opOr, opAnd;
precedence left opSuma, opResta;
precedence left opMult, opDiv;
precedence left opAsig;

start with START;

START           ::= FUNC_HEAD MainProgram parIzq parDer cbOpen {: System.out.println("Inicio main"); currAmbito = "Main"; :} LISTEXP cbClose 
                    FUNC {: 
                                System.out.println("Fin main");
                                printCuadruplos();
                                System.out.println(tabla.toString()); 
                        :} ;

//No terminal para todas las expresiones que pueden haber. Aqui van ifs, for, switch, while, asignaciones, etc
LISTEXP ::= EXP:exp M:m


                {: 
                        completa(exp.listasig, m.intValue()); 
                :} 
                LISTEXP:lexp 
                {: 
                        RESULT = new Expresion(); 
                        RESULT.listasig = lexp.listasig;
                :}
        | EXP:exp M:m 
                {: 
                
                        // RESULT = new Expresion(); 
                        // RESULT.listasig = ifexp.listasig; 
                        completa(exp.listasig, m.intValue());
                        RESULT = new Expresion(); :};

EXP             ::= error {: RESULT = new Expresion(); :}
                | 
                IF:ifexp 
                        {: 
                                RESULT = new Expresion(); 
                                RESULT.listasig = ifexp.listasig; 
                        :}  
                | 
                WHILE:whileexp  
                        {:
                                RESULT = new Expresion(); 
                                RESULT.listasig = whileexp.listasig;
                        :}
                | 
                ASIG    {: RESULT = new Expresion(); :}
                | 
                comment {: RESULT = new Expresion(); :}
                | 
                INIT    {: RESULT = new Expresion(); :}
                | 
                DECL    {: RESULT = new Expresion(); :}
                | 
                FOR:forexp  
                        {: 
                                RESULT = new Expresion();
                                RESULT.listasig = forexp.listasig;
                        :}
                | 
                SELECT:selectexp  {: RESULT = new Expresion(); RESULT.listasig = selectexp.listasig; :}
                | 
                IdF:val {: 
                                int p = val.tipo.indexOf("->");
                                if(p==-1){
                                        printError(valleft,valright,"","","blankCall");
                                }
                                RESULT = new Expresion(); 
                        :}
                | 
                WRITE 
                |
                ret VALS:val 
                        {:   
                                if(currAmbito.equals("Main")){
                                        System.err.println("Error en linea "+(valleft+1)+", columna "+valright+": Return en main");
                                }else{
                                        Simbolo funcion = tabla.getFunction(currAmbito, contadorFunciones);
                                        if(funcion != null){
                                                String retType = funcion.tipo.substring(funcion.tipo.indexOf("->")+2, funcion.tipo.length());
                                                if(retType.equals("void")){
                                                        System.err.println("Error en linea "+(valleft+1)+", columna "+valright+": Return en funcion void");
                                                }else if(!retType.equals(val.tipo)){
                                                        System.err.println("Error en linea "+(valleft+1)+", columna "+valright+": Return de tipo "+val.tipo+" en funcion de tipo "+retType);
                                                }else if(retType.equals(val.tipo)){
                                                        //Cuadruplos de return
                                                }
                                        }
                                }
                                RESULT = new Expresion();
                        :}
                ;


IdF ::= id:ident TypeIdF:val {:    
                                int index = tabla.contains(ident, currAmbito);
                                if(val == -3){
                                        int resultado = 0;
                                        if(index>=0){
                                                Simbolo sym = tabla.getSymbol(ident, currAmbito);
                                                if(!sym.valor.val.equals("")){
                                                        sym.valor.setVal(ident);
                                                        RESULT = sym.valor;
                                                }else{
                                                        RESULT = new Value("error", "notInitialized");
                                                }
                                        }else{
                                                RESULT = new Value("error", "notfound");
                                                RESULT.id = ident;
                                        }
                                }else if(val == -2){
                                        // calls.add(ident);
                                        if(index >= 0) {
                                                Simbolo sym = tabla.getSymbol(ident, currAmbito);
                                                RESULT = new Value(sym.tipo, sym.id);
                                        }else{
                                                RESULT = new Value("error", "notfound");
                                                RESULT.id = ident;
                                        }
                                }else {
                                        int ind = tabla.getIndexVal(ident, currAmbito);
                                        if(index >= 0) {
                                                if(val>=0 && val<=arreglos.get(ind).fin){
                                                        Value arrayValue = arreglos.get(ind).getValue(val);
                                                        if(!arrayValue.val.equals("")){
                                                                RESULT = arrayValue;
                                                        }else{
                                                                RESULT = new Value("error", "notInitialized");
                                                        }
                                                }else{ 
                                                        RESULT = new Value("error", "out of bounds");
                                                }
                                        }else{
                                                RESULT = new Value("error", "notfound");
                                                RESULT.id = ident;
                                        }
                                }
                        :};
        
TypeIdF ::= 
        openBrk number:n closeBrk      
                                        {: 
                                                if(Integer.parseInt(n)>=0){
                                                        RESULT = Integer.parseInt(n); 
                                                }else{
                                                        RESULT = -1; 
                                                }

                                        :}
        |
        parIzq FCALLARGS parDer         {: RESULT = -2; :}
        |
                                        {: RESULT = -3; :};

FCALLARGS ::= VALS:arg FCALLARGS2 | ;
FCALLARGS2 ::= coma VALS:arg FCALLARGS2 | ; 

//No terminal que maneja todas las funciones despues del main
FUNC            ::= RETFUNC FUNC
                | VOIDFUNC FUNC
                | ;

FUNC_HEAD       ::= TIPO:fun_type id:fun_name parIzq TYPE_LIST:args parDer {:
                        int index = tabla.contains(fun_name, currAmbito);
                        if(index == -1){
                                tabla.addVar(args+"->"+fun_type, fun_name, null, "global");
                                contadorFunciones++;
                        }else{
                                printError(fun_nameleft,fun_nameright,fun_name, "Ya existe la función","DetailVariable");
                        }
                :} FUNC_HEAD 
                | voidType id:fun_name parIzq TYPE_LIST:args parDer {:
                        int index = tabla.contains(fun_name, currAmbito);
                        if(index == -1){
                                tabla.addVar(args+"->void", fun_name, null, "global");
                                contadorFunciones++;
                        }else{
                                printError(fun_nameleft,fun_nameright,fun_name, "Ya existe la función","DetailVariable");
                        }
                :} FUNC_HEAD
                |;
TYPE_LIST       ::= TIPO:tipo TYPE_LIST2:tl {: RESULT = tipo + tl; :} | {: RESULT = "void"; :} ;
TYPE_LIST2      ::= coma TIPO:tipo TYPE_LIST2:tl {: RESULT = "x"+tipo+tl; :} | {: RESULT = ""; :};

//Asignacion / Inicializacion
DECL            ::=id:i TIPO:t ASIG2:asig2
                {:
                        int index = tabla.contains(i, currAmbito);
                        if(index == -1){
                                int ind = t.indexOf("array");
                                if(ind==-1){
                                        if(asig2==-1){
                                                Value v = new Value(t, "");
                                                tabla.addVar(t, i, v, currAmbito, new Integer(offset));
                                                if(t.equals("char")){
                                                        offset+=1;
                                                }else if(t.equals("num")){
                                                        offset+=4;
                                                }else if(t.equals("bool")){
                                                        offset+=1;
                                                }
                                                RESULT = i;
                                        }else{
                                                Array m = new Array(0,asig2-1,t);
                                                Value v = new Value(t, arreglos.size()+"");
                                                Value [] arrayTable= new Value[asig2];
                                                for(int j=0; j<asig2; j++){
                                                        arrayTable[j] = new Value(t, "");
                                                }
                                                m.setTabla(arrayTable);
                                                arreglos.add(m);
                                                tabla.addVar(t, i, v, currAmbito);
                                        }
                                }else{
                                        printError(tleft,tright,i,"Declaracion sin tamaño de arreglo","DetailVariable");
                                }
                        }else{
                                RESULT = "";
                                printError(tleft,tright,i,"","declared");
                        }
                :};

INIT            ::= id:i TIPO:t opAsig VALS:v {:
                        int index = tabla.contains(i, currAmbito);
                        if(index == -1){
                                //si no existe la variable revisa si el valor tiene error
                                if(v.tipo.equals("error")){
                                        printError(vleft,vright,i,"",v.val);
                                }else{
                                        int ind = t.indexOf("array");
                                        if(ind!=-1){
                                                String tipo = t.substring(0,ind-1);
                                                if(v.tipo.equals("array")){
                                                        // que sea asignado a un conjunto de elementos entre corchetes("array")
                                                        // Cuando es array el contenido de VALS = Value(tipo->"array", val->"{5,6,7}")
                                                        // Cuando es array el contenido de TIPO = "num array"
                                                        try{
                                                                String[] contenido = v.val.split(",");
                                                                Array m = new Array(0,contenido.length-1,tipo);
                                                                int cont = 0;
                                                                if(tipo.equals("num")){
                                                                        for(int j= contenido.length-1 ; 0 <= j; j--){
                                                                                m.addInt(cont,Integer.parseInt(contenido[j]));
                                                                                cont++;
                                                                        }
                                                                }else if(tipo.equals("char")){
                                                                        for(int j= contenido.length-1 ; 0 <= j; j--){
                                                                                m.addChar(cont,contenido[j].charAt(1));
                                                                                cont++;
                                                                        }
                                                                }else if(tipo.equals("bool")){
                                                                        for(int j= contenido.length-1 ; 0 <= j; j--){
                                                                                if(contenido[j].equals("true") || contenido[j].equals("false")){
                                                                                        m.addBool(cont,contenido[j]);
                                                                                }
                                                                                m.addBool(cont,contenido[j]);
                                                                                cont++;
                                                                        }
                                                                }
                                                                v.setVal(arreglos.size()+"");
                                                                arreglos.add(m);
                                                                tabla.addVar(t, i, v, currAmbito);
                                                        }catch(Exception e){
                                                                printError(vleft,vright,i,"Tipos incompatibles en "+tipo,"DetailVariable");
                                                        }
                                                }else{
                                                        printError((vleft+1),vright,v.tipo,t,"tipos");
                                                }
                                        }else{
                                                if(v.tipo.equals(t)){
                                                        tabla.addVar(t, i, v, currAmbito, new Integer(offset));
                                                        gen(":=", v.val, "", i);
                                                        if(t.equals("char")){
                                                                offset+=1;
                                                        }else if(t.equals("num")){
                                                                offset+=4;
                                                        }else if(t.equals("bool")){
                                                                offset+=1;
                                                        }
                                                        // System.out.println("\tInicializacion: id: "+i+", tipo: "+t+", valor: "+v.val);
                                                        RESULT = i;
                                                }else{
                                                        RESULT = "";
                                                        printError((vleft+1),vright,v.tipo,t,"tipos");
                                                }
                                        }
                                }
                        }else{
                                RESULT = "";
                                printError(vleft,vright,i,"","declared");
                        }
                :};


ASIG            ::= id:i ASIG2:asig2 opAsig VALS:v {: 
                        int index = tabla.contains(i, currAmbito);
                        if(index>=0){
                                if(v.tipo.equals("error")){
                                        printError(vleft+1,vright,i,"",v.val);
                                }else{ 
                                        if(asig2 == -1){
                                                Simbolo sym = tabla.getSymbol(i, currAmbito);
                                                if(v.tipo.equals(sym.tipo)){
                                                        tabla.assignValue(index, new Value(v.tipo, i));
                                                        gen(":=", v.val, "", sym.id);
                                                        // if(v.tipo.equals("boolean")){
                                                        //         System.out.println("Asignacion: Variable "+i+", valor: "+v.getBoolVal());
                                                        // }else if(v.tipo.equals("num")){
                                                        //         System.out.println("Asignacion: Variable "+i+", valor: "+v.getVal());
                                                        // }else if(v.tipo.equals("char")){
                                                        //         System.out.println("Asignacion: Variable "+i+", valor: "+v.getCharVal());
                                                        // }
                                                }else{ 
                                                        printError((vleft+1), vright, v.tipo, sym.tipo,"tipos");
                                                }
                                        }else{
                                                //Cuando esta aqui la unica validacion que necesita es que el valor singular del array sea igualado a otro del mismo
                                                int arrayIndex;
                                                arrayIndex = tabla.getIndexVal(i, currAmbito);
                                                System.out.println("HEEEEY-> Indice del array "+asig2+" Bounds [0, "+arreglos.get(arrayIndex).fin+"] ");
                                                if(asig2>=0 && asig2<=arreglos.get(arrayIndex).fin){
                                                        System.out.println("arrayIndex: "+arrayIndex);
                                                        if(v.tipo.equals(arreglos.get(arrayIndex).tipo) && arrayIndex>=0){
                                                                arreglos.get(arrayIndex).assignValue(asig2,v.val);
                                                        }else{
                                                                printError((vleft+1),vright,v.tipo,arreglos.get(arrayIndex).tipo,"tipos");
                                                        }
                                                }else{ 
                                                        printError(vleft+1, vright, i, asig2+"", "out of bounds");
                                                }
                                        }
                                }
                        }else{
                                System.out.println("index -1 case");
                                printError(vleft,vright,i,"","notDeclared");
                        }
                :};

ASIG2           ::= openBrk number:n closeBrk 
                {: RESULT = Integer.parseInt(n); :}
                |
                {: RESULT = -1; :};

//If
IF              ::= 
                ifstart parIzq COND:cond parDer ifthen M:m1 LISTEXP:exp N:n M:m2 ELSIF:elsif M:m3 ELSE:elsecase endif 
                {:
                        completa(cond.listav, m1.intValue());
                        RESULT = new Expresion();
                        if(elsif == null && elsecase == null){ 
                                RESULT.listasig = fusiona(cond.listaf, fusiona(n.listasig, exp.listasig));
                        }else if(elsif == null && elsecase != null){              
                                completa(cond.listaf, m3.intValue());
                                RESULT.listasig = fusiona(elsecase.listasig, n.listasig);
                        }else if(elsif != null && elsecase == null){
                                completa(cond.listaf, m2.intValue());
                                RESULT.listasig = fusiona(elsif.listasig, n.listasig);
                        }else if(elsif != null && elsecase != null){
                                completa(cond.listaf, m2.intValue());
                                ArrayList<Integer> tempLista = new ArrayList();
                                tempLista.add(elsif.listasig.get(0));
                                completa(tempLista, m3.intValue());
                                elsif.listasig.remove(0);
                                RESULT.listasig = fusiona(elsecase.listasig, fusiona(elsif.listasig, n.listasig));
                        }
                :};
               
ELSIF           ::= elseif parIzq COND:cond parDer ifthen M:m1 LISTEXP:exp N:n M:m2 ELSIF:elseifcase
                {:
                        completa(cond.listav, m1.intValue());
                        RESULT = new Expresion();
                        if(elseifcase !=null){
                                completa(cond.listaf, m2.intValue());
                                RESULT.listasig = fusiona(elseifcase.listasig, fusiona(exp.listasig, n.listasig));
                        }else{
                                RESULT.listasig = fusiona(exp.listasig, fusiona(cond.listaf, n.listasig));
                        }
                :}
                | {: RESULT = null; :};

ELSE            ::= elseclause ifthen LISTEXP:exp
                        {:
                                RESULT = new Expresion();
                                RESULT.listasig = exp.listasig;
                        :}
                | {: RESULT = null; :};

//While
WHILE           ::= 
                whilestart M:m1 parIzq COND:cond parDer M:m2 LISTEXP:exp N:n end 
                        {: 
                                completa(cond.listav, m2.intValue());
                                completa(fusiona(exp.listasig, n.listasig), m1.intValue());
                                RESULT = new Expresion();
                                RESULT.listasig = cond.listaf;
                        :};
//Write
WRITE           ::= writestart parIzq VALS:value parDer 
                {: 
                        if(!value.val.equals("notfound")){
                                gen("WRITE", "", "", value.val); 
                        }else{
                                printError(valueleft, valueright, value.id, "", "notDeclared");
                        }
                :};

//For
FOR             ::= 
                forstart 
                parIzq 
                INIT:id pcoma 
                M:m1 COND:cond pcoma 
                M:m2 CONTADOR N:n1
                parDer
                M:m3 LISTEXP:exp N:n2
                end {: 
                        completa(n1.listasig, m1.intValue());
                        completa(n2.listasig, m2.intValue());
                        completa(cond.listav, m3.intValue());
                        RESULT = new Expresion();
                        RESULT.listasig = cond.listaf;
                        tabla.removeVar(id, currAmbito);  
                        //System.out.println("TABLA SIMBOLOS DESPUES DE FOR: "+tabla.toString()); 
                :};

CONTADOR        ::= 
                id:i contador:cont {: gen("+", "1", i, i); :}; 

//Select
SELECT          ::= 
                selectstart parIzq id:i parDer
                
                OPT:optexp {: 
                        completaArg1(optexp.listav, i); 
                        RESULT = new Expresion();
                        RESULT.listasig = optexp.listasig;
                :}
                end 
                ;

OPT             ::= options VALS:v colon M:m1 
                        {:
                                RESULT = new Expresion();

                                if(!v.val.equals("notfound")){
                                        RESULT.listav.add(cuadruplos.size());
                                        RESULT.listaf.add(cuadruplos.size()+1); 
                                        gen("IF:=", "", v.val +"", m1.intValue()+2+"");
                                        gen("GOTO", "", "", "");
                                }else{
                                        printError(vleft, vright, v.id, "", "notDeclared");
                                }
                                
                        :} 
                LISTEXP:exp breaks N:n M:m2 OPT2:optexp 
                        {:
                                if(optexp != null){
                                        completa(RESULT.listaf, m2.intValue());
                                        RESULT.listasig = fusiona(optexp.listasig, n.listasig);
                                        RESULT.listav = fusiona(optexp.listav, RESULT.listav);
                                }else{
                                        RESULT.listasig = fusiona(RESULT.listaf, n.listasig);
                                }
                        :}
                ;

OPT2            ::= OPT:optexp 
                        {: 
                                RESULT = new Expresion();
                                RESULT.listasig = optexp.listasig;
                                RESULT.listav = optexp.listav;
                        :}
                | 
                        {: RESULT = null; :} ;
        
//Condiciones negadas, normales, con OR o AND
// COND            ::= opNot COND2 
//                 |
//                 COND2 ;
// COND2           ::= id opRel COND3 
//                 | booleano
//                 |
//                 number opRel COND3;
// COND3           ::= id COND4 
//                 | booleano COND4
//                 |
//                 number COND4;
// COND4           ::= opOr COND 
//                 | 
//                 opAnd COND 
//                 | ;

COND ::= 
        parIzq COND:cond parDer 
                {: 
                        RESULT = new Expresion();
                        RESULT.listav = cond.listav;
                        RESULT.listaf = cond.listaf;
                :} 
                COND2:cond2
                {:
                        if(cond2 != null){
                                Expresion temp = RESULT;
                                if(cond2.or){
                                        completa(temp.listaf, cond2.cuad);
                                        RESULT = new Expresion();
                                        RESULT.listav = fusiona(temp.listav, cond2.listav);
                                        RESULT.listaf = cond2.listaf;
                                }else{
                                        completa(temp.listav, cond2.cuad);
                                        RESULT = new Expresion();
                                        RESULT.listaf = fusiona(temp.listaf, cond2.listaf);
                                        RESULT.listav = cond2.listav;
                                }
                        }
                :}

        | opNot COND:cond 
                {:
                        RESULT = new Expresion(); 
                        RESULT.listav = cond.listaf; 
                        RESULT.listaf = cond.listav; 
                :} 
                COND2:cond2
                {:
                        if(cond2 != null){
                                Expresion temp = RESULT;
                                if(cond2.or){
                                        completa(temp.listaf, cond2.cuad);
                                        RESULT = new Expresion();
                                        RESULT.listav = fusiona(temp.listav, cond2.listav);
                                        RESULT.listaf = cond2.listaf;
                                }else{
                                        completa(temp.listav, cond2.cuad);
                                        RESULT = new Expresion();
                                        RESULT.listaf = fusiona(temp.listaf, cond2.listaf);
                                        RESULT.listav = cond2.listav;
                                }
                        }
                :}

        | VALS:i1 opRel:opr VALS:i2 
                {:      
                        boolean isID1 = isID(i1);
                        boolean isID2 = isID(i2);

                        if(isID1 && isID2){
                                int index_id1 = tabla.contains(i1.val, currAmbito);
                                int index_id2 = tabla.contains(i2.val, currAmbito);
                                if(index_id1 > -1 && index_id2 > -1){
                                        RESULT = new Expresion();
                                        RESULT.listav.add(cuadruplos.size());
                                        RESULT.listaf.add(cuadruplos.size()+1);
                                        gen("IF"+opr, i1.val, i2.val, "");
                                        gen("GOTO", "");
                                }else{
                                        if(index_id1 == -1){
                                                printError(i1left, i1right, "en la condicion", "", "notDeclared");
                                        }
                                        if(index_id2 == -1){
                                                printError(i2left, i2right, "en la condicion", "", "notDeclared");                                        
                                        }
                                        RESULT = new Expresion();
                                }
                        }else if((isID1 && !isID2) || (!isID1 && isID2)){
                                int validate = 3;
                                if(isID1){
                                        int index_id1 = tabla.contains(i1.val, currAmbito);
                                        if(index_id1 > -1){
                                                validate = 1;
                                        }else{
                                                validate = 3;
                                        }
                                }else if(isID2){
                                        int index_id2 = tabla.contains(i2.val, currAmbito);
                                        if(index_id2 > -1){
                                                validate = 2;
                                        }else{
                                                validate = 4;
                                        }
                                }

                                RESULT = new Expresion();

                                if(validate < 3){
                                        if((i1.tipo.equals("bool") && (opr.equals("==") || opr.equals("!=")) && i2.tipo.equals("bool"))
                                        ||(i1.tipo.equals("num") && i2.tipo.equals("num"))
                                        ||(i1.tipo.equals("char") && (opr.equals("==") || opr.equals("!=")) && i2.tipo.equals("char"))){
                                                RESULT.listav.add(cuadruplos.size());
                                                RESULT.listaf.add(cuadruplos.size()+1);
                                                gen("IF"+opr, i1.val, i2.val, "");
                                                gen("GOTO", "");
                                        }else{
                                                //printerror tipos incopatibles u operador inorrecto
                                                System.err.println("Tipos incopatibles en condicion");
                                                
                                        }
                                }else{
                                        if(validate == 3){
                                                //printerror i1 no encontrada
                                                printError(i1left, i1right, i1.val, "", "notDeclared");

                                        }else if(validate == 4){
                                                //printerror i2 no encontrada
                                                printError(i2left, i2right, i2.val, "", "notDeclared");
                                                
                                        }
                                }
                        }else if(!isID1 && !isID2){
                                        if((i1.tipo.equals("bool") && (opr.equals("==") || opr.equals("!=")) && i2.tipo.equals("bool"))
                                         ||(i1.tipo.equals("num") && i2.tipo.equals("num"))
                                         ||(i1.tipo.equals("char") && (opr.equals("==") || opr.equals("!=")) && i2.tipo.equals("char"))){
                                                RESULT.listav.add(cuadruplos.size());
                                                RESULT.listaf.add(cuadruplos.size()+1);
                                                gen("IF"+opr, i1.val, i2.val, "");
                                                gen("GOTO", "");
                                        }else{
                                                //printerror tipos incopatibles u operador inorrecto
                                                System.err.println("Tipos incopatibles en condicion");
                                        }                                
                        }
                        
                :} 
                COND2:cond2 
                {:
                        if(cond2 != null){
                                Expresion temp = RESULT;
                                if(cond2.or){
                                        completa(temp.listaf, cond2.cuad);
                                        RESULT = new Expresion();
                                        RESULT.listav = fusiona(temp.listav, cond2.listav);
                                        RESULT.listaf = cond2.listaf;
                                }else{
                                        completa(temp.listav, cond2.cuad);
                                        RESULT = new Expresion();
                                        RESULT.listaf = fusiona(temp.listaf, cond2.listaf);
                                        RESULT.listav = cond2.listav;
                                }
                        }
                                
                        
                :}

        | booleano:boolval 
                {: 
                        RESULT = new Expresion();
                        if(boolval.equals("true")){ 
                                RESULT.listav.add(cuadruplos.size()); 
                        }else{
                                RESULT.listaf.add(cuadruplos.size());
                        }
                        gen("GOTO", "");
                :} 
                COND2:cond2 
                {:
                      if(cond2 != null){
                                Expresion temp = RESULT;
                                if(cond2.or){
                                        completa(temp.listaf, cond2.cuad);
                                        RESULT = new Expresion();
                                        RESULT.listav = fusiona(temp.listav, cond2.listav);
                                        RESULT.listaf = cond2.listaf;
                                }else{
                                        completa(temp.listav, cond2.cuad);
                                        RESULT = new Expresion();
                                        RESULT.listaf = fusiona(temp.listaf, cond2.listaf);
                                        RESULT.listav = cond2.listav;
                                }
                        }  
                :};

COND2 ::= opOr
          M:m 
          COND:cond
          {:
                RESULT = new Expresion(true);
                RESULT.cuad = m.intValue();
                RESULT.listav = cond.listav;
                RESULT.listaf = cond.listaf;
                
          :}
        | 
          opAnd
          M:m 
          COND:cond 
          {:
                RESULT = new Expresion(false);
                RESULT.cuad = m.intValue();
                RESULT.listav = cond.listav;
                RESULT.listaf = cond.listaf;
                
          :}
        | {: RESULT = null; :};

M ::= {: RESULT = new Integer(cuadruplos.size()); :} ;

N ::= 
        {:
                RESULT = new Expresion();
                RESULT.listasig.add(cuadruplos.size());
                gen("GOTO", "");
        :};

// //Expresion Aritmetica
// 1 + 2 * 3
// S
// E + T
// T   T * F
// F   F   num
// num num 3
// 1   2

// 1 + 2 + 3
// S
// E            +       T
// E    +  T   
// F       F            num
// num    num           3
// 1       2

// 1 + (2 + 3)
// S
// E  +   T
// T      F
// F      (E)
// id     E   +   T          
// 1       T       F
//         F       num
//         num     3
//         2
S               ::= E:e                 {: RESULT = e;:};

E               ::= E:e opSuma T:t      {: 
                                                if(e.tipo.equals("error") || t.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(e), y = operationValidation(t);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible");
                                                        }else{
                                                                String temp = nuevoTemp();
                                                                gen("+", e.val, t.val, temp);
                                                                RESULT = new Value("num", temp);
                                                        }
                                                }
                                        :}
                | 
                E:e opResta T:t         {: 
                                                if(e.tipo.equals("error") || t.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(e), y = operationValidation(t);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible");
                                                        }else{
                                                                String temp = nuevoTemp();
                                                                gen("-", e.val, t.val, temp);
                                                                RESULT = new Value("num", temp);
                                                        }
                                                }                                                 
                                        :}
                | 
                T:t                     {:RESULT = t;:};

T               ::= T:t opMult F:f      {: 
                                                if(t.tipo.equals("error") || f.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(t), y = operationValidation(f);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible");
                                                        }else{
                                                                String temp = nuevoTemp();
                                                                gen("*", t.val, f.val, temp);
                                                                RESULT = new Value("num", temp);
                                                        }
                                                }  
                                        :}
                | 
                T:t opDiv F:f           {:
                                                if(t.tipo.equals("error") || f.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(t), y = operationValidation(f);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible");
                                                        }else{
                                                                String temp = nuevoTemp();
                                                                gen("/", t.val, f.val, temp);
                                                                //RESULT = new Value("num", (Integer.parseInt(x) / Integer.parseInt(y))+"");
                                                                RESULT = new Value("num", temp);
                                                        }
                                                }
                                        :}
                | 
                F:f                     {: RESULT=f; :};
                
F               ::=
                number:n                {: RESULT = new Value("num", n); :}
                |
                parIzq E:e parDer       {: RESULT = e; :}
                |
                IdF:val                 {: 
                                                RESULT = val; 
                                        :}
                ;


//Funcion con retorno
RETFUNC         ::= 
                TIPO:t id:val {: currAmbito = val; offset = 0; calls.clear(); :} parIzq ARGS:args 
                        {:
                                int index = tabla.contains(val, "global");
                                if(index >= 0){
                                        Simbolo funcion = tabla.getSymbol(val, currAmbito);
                                        String argType = "";
                                        if(args != null){
                                                for(int i = 0; i < args.tipos.size(); i++){
                                                        argType += args.tipos.get(i);
                                                        if(i < args.tipos.size() - 1){
                                                                argType += "x";
                                                        }
                                                }
                                        }else{
                                                argType = "void";
                                        }
                                        argType += "->"+t;
                                        if(!funcion.tipo.equals(argType)){
                                                printError(argsleft, argsright, argType, "Funcion "+val+" de tipo "+funcion.tipo+" ha sido utilizada como ","DetailVariable");
                                        }
                                }else{
                                        printError(valleft, valright, val, "No ha sido declarada la función ","DetailVariable");
                                }
                        :} 
                parDer cbOpen LISTEXP:exp cbClose;


//Funcion void
VOIDFUNC        ::= voidType id:val {: currAmbito = val; contArgs = 0; offset = 0; calls.clear(); :} parIzq ARGS:args 
                {:
                        
                        int index = tabla.contains(val, "global");
                        if(index >= 0){
                                Simbolo funcion = tabla.getSymbol(val, currAmbito);
                                String argType = "";
                                if(args != null){
                                        for(int i = 0; i < args.tipos.size(); i++){
                                                argType += args.tipos.get(i);
                                                if(i < args.tipos.size() - 1){
                                                        argType += "x";
                                                }
                                        }
                                }else{
                                        argType = "void";
                                }
                                argType += "->void";
                                if(!funcion.tipo.equals(argType)){
                                        printError(argsleft, argsright, argType, "Funcion "+val+" de tipo "+funcion.tipo+" ha sido utilizada como ","DetailVariable");
                                }
                        }else{
                                printError(valleft, valright, val, "No ha sido declarada la función ","DetailVariable");
                        }
                :}
                parDer cbOpen LISTEXP:exp cbClose ;


//Argumentos para funciones
ARGS            ::= TIPO:tipo id:ident ARGS2:arg2       
                        {: 
                                int index = tabla.contains(ident, currAmbito);
                                if(index == -1){
                                        
                                        // tabla.addParam(tipo, ident, new Value(tipo, ""), currAmbito);
                                        contArgs = 1;
                                        RESULT = new Parametros();
                                        if(arg2 != null){
                                                RESULT.ids = arg2.ids;
                                                RESULT.tipos = arg2.tipos;
                                        }
                                        RESULT.ids.add(ident);
                                        RESULT.tipos.add(tipo);
                                }else{
                                        //printerror argumento ya declarado
                                        RESULT = arg2;
                                }
                                if(RESULT.ids.size() > 1){
                                        Collections.reverse(RESULT.ids);
                                        Collections.reverse(RESULT.tipos);
                                        for(int i = 0; i <RESULT.ids.size(); i++){
                                                String currTipo = RESULT.tipos.get(i);
                                                if(i < 4){
                                                        tabla.addParam(currTipo, RESULT.ids.get(i), new Value(currTipo, ""), currAmbito);
                                                }else{
                                                        tabla.addParam(currTipo, RESULT.ids.get(i), new Value(currTipo, ""), currAmbito, new Integer(offset));
                                                        if(currTipo.equals("char") || currTipo.equals("bool")){
                                                                offset+=1;
                                                        }else if(currTipo.equals("num")){
                                                                offset+=4;
                                                        }
                                                }
                                        }
                                }

                        :} 
                | 
                {:
                        RESULT = null;
                :};

ARGS2           ::=  coma TIPO:tipo id:ident ARGS2:arg2 
                        {: 
                                int index = tabla.contains(ident, currAmbito);
                                if(index == -1){
                                        // if(contArgs < 4){
                                        //         tabla.addParam(tipo, ident, new Value(tipo, ""), currAmbito);
                                        // }else{
                                        //         tabla.addParam(tipo, ident, new Value(tipo, ""), currAmbito, new Integer(offset));
                                        //         if(tipo.equals("char") || tipo.equals("bool")){
                                        //                 offset+=1;
                                        //         }else if(tipo.equals("num")){
                                        //                 offset+=4;
                                        //         }
                                        // }
                                        // contArgs++;
                                        RESULT = new Parametros();
                                        if(arg2 != null){
                                                RESULT.ids = arg2.ids;
                                                RESULT.tipos = arg2.tipos;
                                        }
                                        RESULT.ids.add(ident);
                                        RESULT.tipos.add(tipo);
                                        // if(RESULT.ids.size() > 1){
                                        //         Collections.reverse(RESULT.ids);
                                        //         Collections.reverse(RESULT.tipos);
                                        // }
                                }else{
                                        //printerror argumento ya declarado
                                        RESULT = arg2;
                                }
                        :}
                |                                        
                        {: RESULT = null; :};

//Tipos, falta array
TIPO            ::=
                TIPO:t openBrk closeBrk 
                        {: RESULT = t+" array"; :}
                |
                bool:val                
                        {: RESULT = "bool"; :}
                |
                num:val                 
                        {: RESULT = "num"; :}
                | 
                character:val           
                        {: RESULT = "char"; :}
                ;

//Posibles valores que pueden haber: ids, numeros, booleans, strings/char (estos faltan)
VALS            ::=
                booleano:val    
                        {: RESULT = new Value("bool", val); :}
                |
                charval:ch      
                        {: RESULT = new Value("char", ch); :}
                |
                S:val           
                        {: RESULT = val; :}
                |
                ARRVAL0:val      
                        {: RESULT = new Value("array", val); :}
                ;

//Valores para array
ARRVAL0          ::= cbOpen S:v ARRVAL2 cbClose 
                        {: 
                                arrayValue += (v.val + "");
                                RESULT = arrayValue; 
                                arrayValue = ""; 
                        :}
                |cbOpen booleano:v ARRVAL2 cbClose 
                        {: 
                                arrayValue += (v + "");
                                RESULT = arrayValue; 
                                arrayValue = ""; 
                        :}
                |cbOpen charval:v ARRVAL2 cbClose 
                        {: 
                                arrayValue += (v + "");
                                RESULT = arrayValue; 
                                arrayValue = ""; 
                        :};        


ARRVAL2         ::= coma ARRVAL3:v
                |;

ARRVAL3         ::= S:v ARRVAL2       
                        {:   
                                arrayValue += (v.val+",");
                        :}
                |booleano:v ARRVAL2   
                        {:   
                                arrayValue += (v+","); 
                        :}
                |charval:v ARRVAL2    
                        {:   
                                arrayValue += (v+",");
                        :};