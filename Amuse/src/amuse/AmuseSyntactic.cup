package amuse;
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;

parser code {:
        public ArrayList<String> calls = new ArrayList();
        public String arrayValue="";
        public int hayErrores = 0;
        public int contadorNodo = 0;
        public static Nodo padre;
        public TablaSimbolos tabla = new TablaSimbolos();
        public int contadorFunciones = 0;
         
        public void report_error(String message,Object info){
                StringBuffer m=new StringBuffer("Error ");
                if(info instanceof Symbol){
                        Symbol s=((Symbol)info);

                        if(s.left>=0){
                                m.append("en linea "+(s.left+1));
                                if(s.right>=0)
                                        m.append(", columna "+(s.right+1));
                        }
                }
                m.append(": "+message);
                System.err.println(m);
                hayErrores = 1;
        }

        public void report_fatal_error(String message, Object info){
                report_error(message, info);
                hayErrores = 1;
                // System.exit(1);
        }

        public void unrecovered_syntax_error(Symbol cur_token){
                System.out.println(cur_token.toString());
                System.err.println("At line "+(cur_token.left)+", column "+cur_token.right);
                hayErrores = 1;
                // System.exit(1);
        }

        protected void report_expected_token_ids() {
                hayErrores = 1;
	        List<Integer> ids = expected_token_ids();
	        LinkedList<String> list = new LinkedList<String>();
	        for (Integer expected : ids)
		        list.add(symbl_name_from_id(expected));
                // System.err.println("Se esperaba: "+list);
	}

        public String operationValidation(Value e){
                try {
                        int p = e.tipo.indexOf("->");
                        boolean errores= false;
                        if(p>=0){
                                if(functionType(e, p).equals("num")){
                                        return 0+"";
                                }else{
                                        return "error";
                                }
                        }else{
                                Integer.parseInt(e.val);
                                return e.val;                                                        
                        }                                                                           
                } catch (NumberFormatException o) {
                        return "error";
                }
                
        }

        public String functionType(Value e, int indexReturn){
                if((e.tipo.substring(indexReturn+2).equals("num"))){
                        return "num";
                }else{
                        return "error";
                }
        }


        
:};

action code
{:
:}

/**************
 * Terminales *
 **************/

//If
terminal String ifstart, ifthen, elseclause, elseif, endif;

//Estructura 
terminal String MainProgram, end, parIzq, parDer, cbOpen, cbClose, ret, coma, pcoma, openBrk, closeBrk;

//Tipos
terminal String booleano, id, voidType, character;

//Operadores
terminal String opRel, opOr, opAnd, opNot, opAsig;
terminal opSuma, opResta, opMult, opDiv;
terminal String number;


//Valores
terminal String bool, num, charval;

//While                
terminal String whilestart;

//For                
terminal String forstart, contador;

//Write                
terminal String writestart;

//Select             
terminal String selectstart, breaks, options, colon;

terminal String comment;



/*****************
 * No Terminales *
 *****************/

//Inicial y Expresion
non terminal START, EXP;

//If
non terminal IF, ELSIF, ELSE;

//While
non terminal WHILE;

//For
non terminal FOR, CONTADOR;

//Write
non terminal WRITE;

//Select
non terminal SELECT, OPT, OPT2;

//Condiciones multipes, negadas o normales
non terminal COND, COND2, COND3, COND4;

//Headers de funciones
non terminal FUNC_HEAD;
non terminal String TYPE_LIST, TYPE_LIST2;

//Funcion con retorno
non terminal FUNC, RETFUNC, RETFUNC2, RETVAL;
non terminal String RETFUNCBODY;
//Funcion void
non terminal VOIDFUNC, VOIDFUNC2;

non terminal String ARGS, ARGS2; 
non terminal ASIG, ASIG2, INIT, ARRVAL2;
non terminal String ARRVAL;
non terminal String TIPO;
non terminal Value VALS;

non terminal Value F, E, T, S;

non terminal String FCALL;
non terminal FCALLARGS, FCALLARGS2;
//Operadores
// non terminal Object EXP_ARIT, EXPRresp;
// non terminal Integer EXPS, FACT, TERM;
precedence left opSuma, opResta;
precedence left opMult, opDiv;
precedence left opAsig;

start with START;



START           ::= FUNC_HEAD MainProgram parIzq parDer cbOpen {: System.out.println("Inicio main");:} EXP cbClose {: 
                                
                                System.out.println("Fin main");
                                tabla.clearVars(contadorFunciones);
                                System.out.println(tabla.toString()); 
                        :} 
                    FUNC;

//No terminal para todas las expresiones que pueden haber. Aqui van ifs, for, switch, while, asignaciones, etc
EXP             ::= error EXP:exp {: RESULT = exp; :}
                | IF EXP:exp {: RESULT = exp; :}
                | WHILE EXP:exp {: RESULT = exp; :}
                | ASIG EXP:exp {: RESULT = exp; :}
                | comment EXP
                | INIT EXP
                | FOR EXP:exp {: RESULT = exp; :}
                | SELECT EXP:exp {: RESULT = exp; :}
                | FCALL:val {: calls.add(val); RESULT = val;:} EXP
                | WRITE EXP 
                |;



FCALL ::= id:call parIzq FCALLARGS parDer {: RESULT = call; System.out.println("\tLlamado a funcion: "+call);:};

FCALLARGS ::= VALS:arg FCALLARGS2 | ;
FCALLARGS2 ::= coma VALS:arg FCALLARGS2 | ; 

//No terminal que maneja todas las funciones despues del main
FUNC            ::= RETFUNC FUNC
                | VOIDFUNC FUNC
                | ;

FUNC_HEAD       ::= TIPO:fun_type id:fun_name parIzq TYPE_LIST:args parDer {:
                        int index = tabla.contains(fun_name);
                        if(index == -1){
                                tabla.addVar(args+"->"+fun_type, fun_name, null);
                                contadorFunciones++;
                        }else{
                                System.err.println("Error en linea "+fun_nameleft+", columna "+fun_nameright+": Ya existe la función "+fun_name);
                        }
                :} FUNC_HEAD 
                | voidType id:fun_name parIzq TYPE_LIST:args parDer {:
                        int index = tabla.contains(fun_name);
                        if(index == -1){
                                tabla.addVar(args+"->void", fun_name, null);
                                contadorFunciones++;
                        }else{
                                System.err.println("Error en linea "+fun_nameleft+", columna "+fun_nameright+": Ya existe la función "+fun_name);
                        }
                :} FUNC_HEAD
                |;
TYPE_LIST       ::= TIPO:tipo TYPE_LIST2:tl {: RESULT = tipo + tl; :} | ;
TYPE_LIST2      ::= coma TIPO:tipo TYPE_LIST2:tl {: RESULT = "x"+tipo+tl; :} | {: RESULT = ""; :};
//Asignacion / Inicializacion

INIT            ::= id:i TIPO:t opAsig VALS:v {:
                        int index = tabla.contains(i);
                        System.out.println("Asignacion: ID: "+i+", index: "+index);
                        if(index == -1){
                                if(v.tipo.equals("error")){
                                        System.err.println("Error en columna "+vright+", linea "+vleft+": Variable no declarada en inicialización");
                                }else{
                                        if(v.tipo.equals(t)){
                                                tabla.addVar(t, i, v);
                                                System.out.println("\tInicializacion: id: "+i+", tipo: "+t+", valor: "+v.val);
                                        }else{
                                                System.err.println("Error en columna"+vright+", linea "+vleft+": Asignacion de "+v.tipo+" a variable de tipo " +t);
                                        }
                                }
                        }else{
                                System.err.println("Error en columna"+vright+", linea "+vleft+": Variable "+i+" ya fue declarada");
                        }
                :};


ASIG            ::= id:i ASIG2 opAsig VALS:v {: 
                        int index = tabla.contains(i);
                        if(index>=0){
                                if(v.tipo.equals("error")){
                                        if(v.tipo.equals("notfound")){
                                                System.err.println("Error en linea "+vleft+", columna "+vright+": Variable no declarada en asignación");
                                        }else{
                                                System.err.println("Error en linea "+vleft+", columna "+vright+": Tipos incompatibles en operacion");
                                        }
                                }else{
                                        Simbolo sym = tabla.getSymbol(i);
                                        if(v.tipo.equals(sym.tipo)){
                                                tabla.assignValue(index, v);
                                                if(v.tipo.equals("boolean")){
                                                        System.out.println("Asignacion: Variable "+i+", valor: "+v.getBoolVal());
                                                }else if(v.tipo.equals("int")){
                                                        System.out.println("HEEEEY! ");
                                                        System.out.println("Asignacion: Variable "+i+", valor: "+v.getIntVal());
                                                }else if(v.tipo.equals("char")){
                                                        System.out.println("Asignacion: Variable "+i+", valor: "+v.getCharVal());
                                                }
                                        }else{
                                                System.err.println("Error en linea "+vleft+", columna "+vright+": Asignacion de "+v.tipo+" a variable de tipo "+sym.tipo);
                                        }
                                }
                        }else{
                                System.err.println("Error en linea "+vleft+", columna "+vright+": Asignación a variable no declarada");
                        }
                :};

ASIG2           ::= openBrk number:n closeBrk {: RESULT = n; :}
                | {: RESULT = -1; :};

//If
IF              ::= {: System.out.println("Inicio IF"); :} 
                ifstart parIzq COND parDer 
                {: System.out.println("\tCondicion if"); :} 
                ifthen EXP ELSIF endif 
                {: System.out.println("Fin if"); :};
ELSIF           ::= elseif parIzq COND parDer 
                {: System.out.println("\tCondicion elseif"); :} ifthen EXP ELSIF 
                | 
                ELSE;
ELSE            ::= elseclause ifthen 
                {: System.out.println("\tElse"); :} EXP 
                | ;

//While
WHILE           ::= 
                whilestart {: System.out.println("Inicio WHILE"); :}  parIzq COND parDer 
                {:System.out.println("\tCondicion while");:} 
                EXP end {: System.out.println("fin while"); :};

//Write
WRITE           ::= 
                writestart parIzq VALS:val parDer 
                {:System.out.println("\tWRITE Valor:"+val);:};

//For
FOR             ::= 
                forstart {: System.out.println("Inicio FOR"); :} parIzq INIT pcoma COND 
                {:System.out.println("\tCondicion for");:}
                pcoma CONTADOR parDer
                {:System.out.println("\tCondicion for");:}
                ASIG 
                end {: System.out.println("fin for"); :};

CONTADOR        ::= 
                id:i contador:cont {:System.out.println("\t Contador: id: "+i+", contador: "+cont);:};

//Select
SELECT          ::= {: System.out.println("Inicio Select"); :}
                selectstart parIzq id:i parDer
                {:System.out.println("\tVariable:"+i);:}
                OPT
                end 
                {: System.out.println("fin select"); :};

OPT             ::= options VALS:v {: System.out.println("\t\tOpcion-valor: "+v); :} colon EXP breaks OPT2;
OPT2            ::= OPT | ;
        
//Condiciones negadas, normales, con OR o AND
COND            ::= opNot COND2 
                |
                COND2 ;
COND2           ::= id opRel COND3 
                | booleano
                |
                number opRel COND3;
COND3           ::= id COND4 
                | booleano COND4
                |
                number COND4;
COND4           ::= opOr COND 
                | 
                opAnd COND 
                | ;

// //Expresion Aritmetica
S               ::= E:e {: RESULT = e;:};
E               ::= E:e opSuma T:t      {: 
                                                if(e.tipo.equals("error") || t.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(e), y = operationValidation(t);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible types for operation");
                                                        }else{
                                                                RESULT = new Value("num", (Integer.parseInt(x) + Integer.parseInt(y))+"");
                                                        }
                                                }
                                        :}
                | 
                E:e opResta T:t         {: 
                                                if(e.tipo.equals("error") || t.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(e), y = operationValidation(t);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible types for operation");
                                                        }else{
                                                                RESULT = new Value("num", (Integer.parseInt(x) - Integer.parseInt(y))+"");
                                                        }
                                                }                                                 
                                        :}
                | 
                T:t                     {:RESULT = t;:};
T               ::= T:t opMult F:f      {: 
                                                if(t.tipo.equals("error") || f.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(t), y = operationValidation(f);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible types for operation");
                                                        }else{
                                                                RESULT = new Value("num", (Integer.parseInt(x) * Integer.parseInt(y))+"");
                                                        }
                                                }  
                                        :}
                | 
                T:t opDiv F:f           {: 
                                                if(t.tipo.equals("error") || f.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(t), y = operationValidation(f);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible types for operation");
                                                        }else{
                                                                RESULT = new Value("num", (Integer.parseInt(x) / Integer.parseInt(y))+"");
                                                        }
                                                }  
                                        :}
                | 
                F:f                     {:RESULT=f;:};
F               ::= number:n {:RESULT = new Value("num", n);:}
                |
                parIzq E:e parDer {:RESULT = e;:}
                |
                id:i {:
                                int index = tabla.contains(i);
                                int resultado = 0;
                                if(index>=0){
                                        Simbolo sym = tabla.getSymbol(i);
                                        RESULT = sym.valor;
                                }else{
                                        RESULT = new Value("error", "notfound");
                                }
                        :}
                |
                FCALL:val       
                        {: 
                                calls.add(val);
                                int index = tabla.contains(val);
                                if(index >= 0) {
                                        Simbolo sym = tabla.getSymbol(val);
                                        RESULT = new Value(sym.tipo, sym.id);
                                }else{
                                        System.err.println("ACA VEEEH");
                                        RESULT = new Value("error", "notfound");
                                }
                        :}
                ;


//Funcion con retorno
RETFUNC         ::= TIPO:t id:val {: calls.clear(); :} parIzq ARGS:args parDer
                cbOpen RETFUNCBODY {:
                        // boolean rec = false;
                        // for(int i = 0; i < calls.size(); i++){
                        //         if(calls.get(i).equals(val)){
                        //                 rec = true;
                        //                 break;
                        //         }
                        // }
                        // if(rec){
                        //         System.out.println("La funcion "+val+" es recursiva");
                        // }
                        int index = tabla.contains(val);
                        if(index >= 0){
                                Simbolo funcion = tabla.getSymbol(val);
                                if(funcion.tipo.equals(args+"->"+t)){
                                        System.out.println("Funcion "+val+", tipo: "+args+"->"+t);
                                }else{
                                        System.err.println("Error en linea "+argsleft+", columna "+argsright+": Funcion "+val+" definida como "+(args+"->"+t)+" pero fue declarada como "+funcion.tipo);
                                }
                        }else{
                                System.err.println("Error en linea "+valleft+", columna "+valright+": Funcion "+val+" no declarada");
                        }
                :} cbClose 
                ;
RETFUNCBODY     ::= EXP:exp ret RETVAL;
RETVAL          ::= VALS:retVal ;

//Funcion void
VOIDFUNC        ::= voidType id:val {:System.out.println("VOID FUNCTION "+val+" START"); calls.clear(); :} parIzq ARGS:args parDer
                cbOpen EXP {: 
                        // boolean rec = false;
                        // for(int i = 0; i < calls.size(); i++){
                        //         if(calls.get(i).equals(val)){
                        //                 rec = true;
                        //                 break;
                        //         }
                        // }
                        // if(rec){
                        //         System.out.println("La funcion "+val+" es recursiva");
                        // }
                        int index = tabla.contains(val);
                        if(index >= 0){
                                Simbolo funcion = tabla.getSymbol(val);
                                if(funcion.tipo.equals(args+"->void")){
                                        System.out.println("FIN FUNCTION");
                                }else{
                                        System.err.println("Error en linea "+argsleft+", columna "+argsright+": Funcion "+val+" definida como "+(args+"->void")+" pero fue declarada como "+funcion.tipo);
                                }
                        }else{
                                System.err.println("Error en linea "+valleft+", columna "+valright+": Funcion no declarada");
                        }
                :} cbClose ;


//Argumentos para funciones
ARGS            ::= TIPO:t id:i ARGS2:arg2       {: RESULT = t+arg2; :} 
                | ;
ARGS2           ::=  coma TIPO:t id:i ARGS2:arg2 {: RESULT = "x"+t+arg2; :}
        |                                        {: RESULT = ""; :};

//Tipos, falta array
TIPO            ::= 
                TIPO:t openBrk closeBrk {: RESULT = t+" array"; :}
                |
                bool:val                {: RESULT = "bool"; :}
                |
                num:val                 {: RESULT = "num"; :}
                | 
                character:val           {: RESULT = "char"; :}
                ;

//Posibles valores que pueden haber: ids, numeros, booleans, strings/char (estos faltan)
VALS            ::= 
                booleano:val    {: RESULT = new Value("bool", val); :}
                |
                charval:ch      {: RESULT = new Value("char", ch.charAt(1)+""); :}
                |
                S:val           {:  RESULT = val; :}
                |
                ARRVAL:val      {: RESULT = new Value("array", val); :}
                ;

//Valores para array
ARRVAL          ::= cbOpen S:val      {: arrayValue = val + ""; :} ARRVAL2 {: RESULT = arrayValue; arrayValue = ""; :} cbClose 
                |
                cbOpen  cbClose       {: RESULT = ""; :};

ARRVAL2           ::=  coma S:val       {: arrayValue += (", " + val); :} ARRVAL2
                |;
                //| comilla letra:val{: System.out.println("val es:"+String.valueOf(val)); RESULT = String.valueOf(val); :} comilla;
