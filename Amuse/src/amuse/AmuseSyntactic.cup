package amuse;
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;

parser code {:
        public ArrayList<String> calls = new ArrayList();
        public String arrayValue="";

       public void report_error(String message,Object info){
                StringBuffer m=new StringBuffer("Error ");
                if(info instanceof Symbol){
                        Symbol s=((Symbol)info);

                        if(s.left>=0){
                                m.append("en linea "+(s.left));
                                if(s.right>=0)
                                        m.append(", columna "+(s.right));
                        }
                }
                m.append(": "+message);
                System.err.println(m);
        }

        public void report_fatal_error(String message, Object info){
                report_error(message, info);
                // System.exit(1);
        }

        public void unrecovered_syntax_error(Symbol cur_token){
                System.out.println(cur_token.toString());
                System.err.println("At line "+(cur_token.left)+", column "+cur_token.right);
                // System.exit(1);
        }

        protected void report_expected_token_ids() {
	        List<Integer> ids = expected_token_ids();
	        LinkedList<String> list = new LinkedList<String>();
	        for (Integer expected : ids)
		        list.add(symbl_name_from_id(expected));
                // System.err.println("Se esperaba: "+list);
	}
        
:};

action code
{:
:}

/**************
 * Terminales *
 **************/

//If
terminal String ifstart, ifthen, elseclause, elseif, endif;

//Estructura 
terminal String MainProgram, begin, end, parIzq, parDer, cbOpen, cbClose, ret, coma, pcoma, openBrk, closeBrk;

//Tipos
terminal String booleano, id, voidType, character;

//Operadores
terminal String opRel, opArit, opOr, opAnd, opNot, opAsig;
terminal opSuma, opResta, opMult, opDiv;
terminal String number;

//Valores
terminal String bool, num, charval;

//While                
terminal String whilestart;

//For                
terminal String forstart;

//Select             
terminal String selectstart, breaks, options, colon;

terminal String comment;


/*****************
 * No Terminales *
 *****************/

//Inicial y Expresion
non terminal START, EXP;

//If
non terminal IF, ELSIF, ELSE;

//While
non terminal WHILE;

//For
non terminal FOR;

//Select
non terminal SELECT, OPT;

//Condiciones multipes, negadas o normales
non terminal COND, COND2, COND3, COND4;

//Funcion con retorno
non terminal FUNC, RETFUNC, RETFUNC2, RETVAL;
non terminal String RETFUNCBODY;
//Funcion void
non terminal VOIDFUNC, VOIDFUNC2;

non terminal ARGS, ARGS2, ASIG, ASIG2, INIT, INIT2, ARRVAL2, BRKS, BRKS2;
non terminal String ARRVAL;
non terminal String VALS, TIPO;

non terminal Integer E,T,F;
non terminal Integer S;

non terminal String FCALL;
non terminal FCALLARGS, FCALLARGS2;
//Operadores
// non terminal Object EXP_ARIT, EXPRresp;
// non terminal Integer EXPS, FACT, TERM;


start with START;





START           ::= MainProgram parIzq parDer cbOpen {: System.out.println("Inicio main");:} EXP cbClose {: System.out.println("Fin main"); :} FUNC;

//No terminal para todas las expresiones que pueden haber. Aqui van ifs, for, switch, while, asignaciones, etc
EXP             ::= IF EXP:exp {: RESULT = exp; :}
                | WHILE EXP:exp {: RESULT = exp; :}
                | ASIG EXP:exp {: RESULT = exp; :}
                | comment EXP
                | INIT EXP
                | error  EXP:exp {: RESULT = exp; :}
                | FOR EXP:exp {: RESULT = exp; :}
                | SELECT EXP:exp {: RESULT = exp; :}
                | S EXP:exp {: RESULT = exp; :}
                | FCALL:val {: calls.add(val);:} EXP 
                | ;

FCALL ::= id:call {: RESULT = call; System.out.println("\tLlamado a funcion: "+call);:} parIzq FCALLARGS parDer;

FCALLARGS ::= VALS:arg FCALLARGS2 | ;
FCALLARGS2 ::= coma VALS:arg FCALLARGS2 | ; 

//No terminal que maneja todas las funciones despues del main
FUNC            ::= RETFUNC FUNC
                | VOIDFUNC FUNC
                | error FUNC 
                | ;

//Asignacion / Inicializacion

INIT            ::= id:i TIPO:t opAsig VALS:v {:System.out.println("\tInicializacion: id: "+i+", tipo: "+t+", valor: "+v);:};


ASIG            ::= id:i ASIG2 opAsig VALS:v {: System.out.println("\tAsignacion: id: "+i+", valor: "+v);:} ;
ASIG2           ::= openBrk number closeBrk
                | ;


BRKS            ::= openBrk BRKS2 closeBrk;
BRKS2           ::= number:n 
                |;

//If
IF              ::= {: System.out.println("Inicio IF"); :} 
                ifstart parIzq COND parDer 
                {: System.out.println("\tCondicion if"); :} 
                ifthen EXP ELSIF endif 
                {: System.out.println("Fin if"); :};
ELSIF           ::= elseif parIzq COND parDer 
                {: System.out.println("\tCondicion elseif"); :} ifthen EXP ELSIF 
                | 
                ELSE;
ELSE            ::= elseclause ifthen 
                {: System.out.println("\tElse"); :} EXP 
                | ;

//While
WHILE           ::= {: System.out.println("Inicio WHILE"); :} 
                whilestart parIzq COND parDer 
                {:System.out.println("\tCondicion while");:} 
                EXP end {: System.out.println("fin while"); :};

//For
FOR             ::= {: System.out.println("Inicio FOR"); :}
                forstart parIzq ASIG pcoma COND 
                {:System.out.println("\tCondicion for");:}
                pcoma COND parDer 
                {:System.out.println("\tCondicion for");:}
                EXP 
                end {: System.out.println("fin for"); :};

//Select
SELECT          ::= {: System.out.println("Inicio Select"); :}
                selectstart parIzq id:i parDer
                {:System.out.println("\tVariable:"+i);:}
                OPT
                end 
                {: System.out.println("fin select"); :};

OPT             ::= options VALS:v colon EXP breaks OPT
                {: System.out.println("\t\tOpcion-valor: "+v); :}
                | 
                options VALS:v colon EXP breaks
                {: System.out.println("\t\tOpcion-valor: "+v); :};
        
//Condiciones negadas, normales, con OR o AND
COND            ::= opNot COND2 
                |
                COND2 ;
COND2           ::= id opRel COND3 
                |
                number opRel COND3;
COND3           ::= id COND4 
                | 
                number COND4;
COND4           ::= opOr COND 
                | 
                opAnd COND 
                | ;

// //Expresion Aritmetica
S               ::= E:e {: RESULT = e;:};
E               ::= E:e opSuma T:t {: RESULT= new Integer(e.intValue()+t.intValue()); :}
                | 
                E:e opResta T:t {: RESULT = new Integer(e.intValue()-t.intValue()); :}
                | 
                T:t{:RESULT = t;:};
T               ::= T:t opMult F:f {: RESULT = new Integer(t.intValue() * f.intValue());:}
                | 
                T:t opDiv F:f {: RESULT = new Integer(t.intValue() / f.intValue());:}
                | 
                F:f {:RESULT=f;:};
F               ::= number:n {:RESULT = new Integer(n);:}
                |
                parIzq E:e parDer {:RESULT = e;:};


//Funcion con retorno
RETFUNC         ::= TIPO {:System.out.println("FUNCTION START"); calls.clear(); :} RETFUNC2;
RETFUNC2        ::= id:val parIzq ARGS {:System.out.println("\tArgumentos");:} parDer 
                cbOpen {: System.out.println("\tFUNCTION HEADER "); :} RETFUNCBODY cbClose 
                {:
                        boolean rec = false;
                        for(int i = 0; i < calls.size(); i++){
                                if(calls.get(i).equals(val)){
                                        rec = true;
                                        break;
                                }
                        }
                        if(rec){
                                System.out.println("La funcion "+val+" es recursiva");
                        }
                        System.out.println("FIN FUNCTION");
                :};
RETFUNCBODY     ::= EXP:exp ret {:System.out.print("\tRETURN - ");:} RETVAL;
RETVAL          ::= VALS:retVal {: System.out.println("Return value: "+retVal); :};

//Funcion void
VOIDFUNC        ::= voidType {:System.out.println("VOID FUNCTION START"); calls.clear(); :} VOIDFUNC2;
VOIDFUNC2       ::= id:val parIzq ARGS {:System.out.println("\tArgumentos");:} parDer
                cbOpen EXP cbClose {: 
                        boolean rec = false;
                        for(int i = 0; i < calls.size(); i++){
                                if(calls.get(i).equals(val)){
                                        rec = true;
                                        break;
                                }
                        }
                        if(rec){
                                System.out.println("La funcion "+val+" es recursiva");
                        }
                        System.out.println("FIN FUNCTION");
                :};


//Argumentos para funciones
ARGS            ::= TIPO id ARGS2 
                | ;
ARGS2           ::=  coma TIPO id ARGS2
                | ;

//Tipos, falta array
TIPO            ::= 
                TIPO:t openBrk closeBrk {: RESULT = t+" array"; :}
                |
                bool:val {: RESULT = "bool"; :}
                | 
                num:val {: RESULT = "num"; :}
                | 
                character:val {: RESULT = "char"; :}
                ;

//Posibles valores que pueden haber: ids, numeros, booleans, strings/char (estos faltan)
VALS            ::= id:val {: RESULT = val; :}
                | 
                booleano:val {: RESULT = val; :}
                |
                charval:ch {: RESULT = ch; :}
                |
                S:val {: RESULT = val.intValue() + ""; :}
                |
                ARRVAL:val {: RESULT = val; :}
                ;

//Valores para array
ARRVAL            ::= cbOpen S:val {: arrayValue = val + ""; :} ARRVAL2 {: RESULT = arrayValue; arrayValue = ""; :} cbClose 
                | cbOpen  cbClose {: RESULT = ""; :};
ARRVAL2           ::=  coma S:val {: arrayValue += (", " + val); :} ARRVAL2
                | ;
                //| comilla letra:val{: System.out.println("val es:"+String.valueOf(val)); RESULT = String.valueOf(val); :} comilla;
