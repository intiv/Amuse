package amuse;
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;

parser code {:
        public ArrayList<String> calls = new ArrayList();
        public String arrayValue="";
        public int hayErrores = 0;
        public int contadorNodo = 0;
        public static Nodo padre;
        public TablaSimbolos tabla = new TablaSimbolos();
        public ArrayList<Array> arreglos = new ArrayList();
        public int contadorFunciones = 0;
        public ArrayList<Cuadruplo> cuadruplos = new ArrayList();
         
        public void gen(String op, String arg1, String arg2, String res){
                cuadruplos.add(new Cuadruplo(op, arg1, arg2, res));
        }

        public void gen(String op, String res){
                cuadruplos.add(new Cuadruplo(op, res));
        }

        public ArrayList<Integer> fusiona(ArrayList<Integer> l1, ArrayList<Integer> l2){
                ArrayList<Integer> retVal = new ArrayList();
                retVal.addAll(l1);
                for(Integer i : l2){
                        if(!retVal.contains(i)){
                                retVal.add(i);
                        }

                }
                return retVal; 
        }

        public void completa(ArrayList<Integer> lista, int cuad){
                for(Integer i: lista){
                        cuadruplos.get(i.intValue()).setResult(cuad+"");
                }
        }

        public void report_error(String message,Object info){
                StringBuffer m=new StringBuffer("Error ");
                if(info instanceof Symbol){
                        Symbol s=((Symbol)info);

                        if(s.left>=0){
                                m.append("en linea "+(s.left+1));
                                if(s.right>=0)
                                        m.append(", columna "+(s.right+1));
                        }
                }
                m.append(": "+message);
                System.err.println(m);
                hayErrores = 1;
        }

        public void report_fatal_error(String message, Object info){
                report_error(message, info);
                hayErrores = 1;
                // System.exit(1);
        }

        public void unrecovered_syntax_error(Symbol cur_token){
                System.out.println(cur_token.toString());
                System.err.println("At line "+(cur_token.left)+", column "+cur_token.right);
                hayErrores = 1;
                // System.exit(1);
        }

        protected void report_expected_token_ids() {
                hayErrores = 1;
	        List<Integer> ids = expected_token_ids();
	        LinkedList<String> list = new LinkedList<String>();
	        for (Integer expected : ids)
		        list.add(symbl_name_from_id(expected));
                // System.err.println("Se esperaba: "+list);
	}

        public String operationValidation(Value e){
                try {
                        int p = e.tipo.indexOf("->");
                        boolean errores= false;
                        if(p>=0){
                                if(functionType(e, p).equals("num")){
                                        return 0+"";
                                }else{
                                        return "error";
                                }
                        }else{
                                Integer.parseInt(e.val);
                                return e.val;                                                        
                        }                                                                           
                } catch (NumberFormatException o) {
                        return "error";
                }
                
        }

        public String functionType(Value e, int indexReturn){
                if((e.tipo.substring(indexReturn+2).equals("num"))){
                        return "num";
                }else{
                        return "error";
                }
        }


        
:};

action code
{:
:}

/**************
 * Terminales *
 **************/

//If
terminal String ifstart, ifthen, elseclause, elseif, endif;

//Estructura 
terminal String MainProgram, end, parIzq, parDer, cbOpen, cbClose, ret, coma, pcoma, openBrk, closeBrk;

//Tipos
terminal String booleano, id, voidType, character;

//Operadores
terminal String opRel, opOr, opAnd, opNot, opAsig;
terminal opSuma, opResta, opMult, opDiv;
terminal String number;




//Valores
terminal String bool, num, charval;

//While                
terminal String whilestart;

//For                
terminal String forstart, contador;

//Write                
terminal String writestart;

//Select             
terminal String selectstart, breaks, options, colon;

terminal String comment;



/*****************
 * No Terminales *
 *****************/

//Inicial y Expresion
non terminal Expresion START, EXP;
non terminal Expresion N;
non terminal Integer M;


//If
non terminal IF, ELSIF, ELSE;

//While
non terminal WHILE;

//For
non terminal FOR, CONTADOR;

//Write
non terminal WRITE;

//Select
non terminal SELECT, OPT, OPT2;

//Condiciones multipes, negadas o normales
non terminal Expresion COND, COND2;

//Headers de funciones
non terminal FUNC_HEAD;
non terminal String TYPE_LIST, TYPE_LIST2;

//Funcion con retorno
non terminal FUNC, RETFUNC, RETVAL;
non terminal String RETFUNCBODY;
//Funcion void
non terminal VOIDFUNC;

non terminal String ARGS, ARGS2; 
non terminal ASIG, ARRVAL1, ARRVAL2, ARRVAL3;
non terminal Integer ASIG2;
non terminal String INIT;
non terminal String ARRVAL0;
non terminal String TIPO;
non terminal Value VALS;

non terminal Value F, E, T, S;

non terminal Value IdF;
non terminal Integer TypeIdF;
non terminal FCALLARGS, FCALLARGS2;
//Operadores
// non terminal Object EXP_ARIT, EXPRresp;
// non terminal Integer EXPS, FACT, TERM;
precedence left opOr, opAnd;
precedence left opSuma, opResta;
precedence left opMult, opDiv;
precedence left opAsig;

start with START;



START           ::= FUNC_HEAD MainProgram parIzq parDer cbOpen {: System.out.println("Inicio main");:} EXP cbClose {: 
                                System.out.println("Fin main");
                                tabla.disableVars(contadorFunciones);
                                System.out.println(tabla.toString()); 
                        :} 
                    FUNC;

//No terminal para todas las expresiones que pueden haber. Aqui van ifs, for, switch, while, asignaciones, etc
EXP             ::= error EXP:exp {: RESULT = exp; :}
                | IF EXP:exp {: RESULT = exp; :}
                | WHILE EXP:exp {: RESULT = exp; :}
                | ASIG EXP:exp {: RESULT = exp; :}
                | comment EXP
                | INIT EXP
                | FOR EXP:exp {: RESULT = exp; :}
                | SELECT EXP:exp {: RESULT = exp; :}
                | IdF:val {: :} EXP
                | WRITE EXP 
                |;



IdF ::= id:call TypeIdF:val {:    
                                int index = tabla.contains(call);
                                if(val == -2){
                                        int resultado = 0;
                                        if(index>=0){
                                                Simbolo sym = tabla.getSymbol(call);
                                                RESULT = sym.valor;
                                        }else{
                                                RESULT = new Value("error", "notfound");
                                        }
                                }else if(val == -3){
                                        calls.add(call);
                                        if(index >= 0) {
                                                Simbolo sym = tabla.getSymbol(call);
                                                RESULT = new Value(sym.tipo, sym.id);
                                        }else{
                                                RESULT = new Value("error", "notfound");
                                        }
                                }else {
                                        int ind = tabla.getIndexVal(call);
                                        if(index >= 0) {
                                                if(ind>=0){
                                                        if(val>=0 && val<=arreglos.get(ind).fin){
                                                                RESULT = arreglos.get(ind).getValue(val);
                                                        }else{
                                                                System.out.println("out of bounds");
                                                                RESULT = new Value("error", "out of bounds");
                                                        }
                                                }else{
                                                        System.out.println("not array");
                                                        RESULT = new Value("error", "not array");
                                                }
                                        }else{
                                                RESULT = new Value("error", "notfound");
                                        }
                                        
                                }
                        :};

TypeIdF ::= parIzq FCALLARGS parDer     {: RESULT = -3; :}
        |openBrk number:n closeBrk      
                                        {: 
                                                if(Integer.parseInt(n)>=0){
                                                        RESULT = Integer.parseInt(n); 
                                                }else{
                                                        RESULT = -1; 
                                                }

                                        :}
        |                               {: RESULT = -2; :};

FCALLARGS ::= VALS:arg FCALLARGS2 | ;
FCALLARGS2 ::= coma VALS:arg FCALLARGS2 | ; 

//No terminal que maneja todas las funciones despues del main
FUNC            ::= RETFUNC FUNC
                | VOIDFUNC FUNC
                | ;

FUNC_HEAD       ::= TIPO:fun_type id:fun_name parIzq TYPE_LIST:args parDer {:
                        int index = tabla.contains(fun_name);
                        if(index == -1){
                                tabla.addVar(args+"->"+fun_type, fun_name, null);
                                contadorFunciones++;
                        }else{
                                System.err.println("Error en linea "+fun_nameleft+", columna "+fun_nameright+": Ya existe la función "+fun_name);
                        }
                :} FUNC_HEAD 
                | voidType id:fun_name parIzq TYPE_LIST:args parDer {:
                        int index = tabla.contains(fun_name);
                        if(index == -1){
                                tabla.addVar(args+"->void", fun_name, null);
                                contadorFunciones++;
                        }else{
                                System.err.println("Error en linea "+fun_nameleft+", columna "+fun_nameright+": Ya existe la función "+fun_name);
                        }
                :} FUNC_HEAD
                |;
TYPE_LIST       ::= TIPO:tipo TYPE_LIST2:tl {: RESULT = tipo + tl; :} | ;
TYPE_LIST2      ::= coma TIPO:tipo TYPE_LIST2:tl {: RESULT = "x"+tipo+tl; :} | {: RESULT = ""; :};

//Asignacion / Inicializacion
INIT            ::= id:i TIPO:t opAsig VALS:v {:
                        int index = tabla.contains(i);
                        System.out.println("Asignacion: ID: "+i+", index: "+index);
                        if(index == -1){
                                //si no existe la variable revisa si el valor tiene error
                                if(v.tipo.equals("error")){
                                        if(v.tipo.equals("notfound")){
                                                System.err.println("Error en linea "+vleft+", columna "+vright+": Variable no declarada en asignación");
                                        }else if(v.tipo.equals("out of bounds")){
                                                System.err.println("Error en linea "+(vleft+1)+", columna "+vright+": Indice de arreglo esta fuera de alcance ");
                                        }else{
                                                System.err.println("Error en linea "+vleft+", columna "+vright+": Tipos incompatibles en operacion");
                                        }
                                }else{  
                                        int ind = t.indexOf("array");
                                        if(ind!=-1){
                                                //revisa si es de tipo array o no
                                                String tipo = t.substring(0,ind-1);
                                                if(v.tipo.equals("array")){
                                                        // que sea asignado a un conjunto de elementos entre corchetes("array")
                                                        // Cuando es array el contenido de VALS = Value(tipo->"array", val->"{5,6,7}")
                                                        // Cuando es array el contenido de TIPO = "num array"
                                                        try{
                                                                String[] contenido = v.val.split(",");
                                                                Array m = new Array(0,contenido.length-1,tipo);
                                                                int cont = 0;
                                                                if(tipo.equals("num")){
                                                                        for(int j= contenido.length-1 ; 0 <= j; j--){
                                                                                m.addInt(cont,Integer.parseInt(contenido[j]));
                                                                                cont++;
                                                                        }
                                                                }else if(tipo.equals("char")){
                                                                        for(int j= contenido.length-1 ; 0 <= j; j--){
                                                                                m.addChar(cont,contenido[j].charAt(1));
                                                                                cont++;
                                                                        }
                                                                }else if(tipo.equals("bool")){
                                                                        for(int j= contenido.length-1 ; 0 <= j; j--){
                                                                                if(contenido[j].equals("true") || contenido[j].equals("false")){
                                                                                        m.addBool(cont,contenido[j]);
                                                                                }
                                                                                m.addBool(cont,contenido[j]);
                                                                                cont++;
                                                                        }
                                                                }
                                                                v.setVal(arreglos.size()+"");
                                                                arreglos.add(m);
                                                                tabla.addVar(t, i, v);
                                                        }catch(Exception e){
                                                                e.printStackTrace();
                                                                System.err.println("Error en columna"+vright+", linea "+vleft+": error valores del arreglo deben de ser tipo "+tipo);
                                                        }
                                                }else{
                                                        System.err.println("Error en columna"+vright+", linea "+vleft+": Asignacion de "+v.tipo+" a variable de tipo " +t);
                                                }
                                        }else{
                                                if(v.tipo.equals(t)){
                                                        tabla.addVar(t, i, v);
                                                        System.out.println("\tInicializacion: id: "+i+", tipo: "+t+", valor: "+v.val);
                                                        RESULT = i;
                                                }else{
                                                        RESULT = "";
                                                        System.err.println("Error en columna"+vright+", linea "+vleft+": Asignacion de "+v.tipo+" a variable de tipo " +t);
                                                }
                                        }
                                        
                                }
                        }else{
                                RESULT = "";
                                System.err.println("Error en columna"+vright+", linea "+vleft+": Variable "+i+" ya fue declarada");
                        }
                :};


ASIG            ::= id:i ASIG2:asig2 opAsig VALS:v {: 
                        int index = tabla.contains(i);
                        if(index>=0){
                                if(!v.tipo.equals("error")){
                                        if(asig2 != -1){
                                                //Cuando esta aqui la unica validacion que necesita es que el valor singular del array sea igualado a otro del mismo
                                                int arrayIndex;
                                                arrayIndex = tabla.getIndexVal(i);
                                                if(arrayIndex>0){
                                                        if(v.tipo.equals(arreglos.get(arrayIndex).tipo)){
                                                                arreglos.get(arrayIndex).assignValue(asig2,v.val);
                                                        }else{
                                                                System.err.println("Error en linea "+(vleft+1)+", columna "+vright+": Asignacion de "+v.tipo+" a variable de tipo "+arreglos.get(arrayIndex).tipo);
                                                        }
                                                }else{
                                                        if(arrayIndex==-1){
                                                                System.err.println("Error en linea "+(vleft+1)+", columna "+vright+": Variable no es tipo arreglo");
                                                        }else{
                                                                System.err.println("Error en linea "+(vleft+1)+", columna "+vright+": Asignación a variable no declarada");
                                                        }
                                                }
                                        }else{
                                                Simbolo sym = tabla.getSymbol(i);
                                                if(v.tipo.equals(sym.tipo)){
                                                        tabla.assignValue(index, v);
                                                        gen(":=", v.val, "", sym.id);
                                                        if(v.tipo.equals("boolean")){
                                                                System.out.println("Asignacion: Variable "+i+", valor: "+v.getBoolVal());
                                                        }else if(v.tipo.equals("num")){
                                                                System.out.println("Asignacion: Variable "+i+", valor: "+v.getIntVal());
                                                        }else if(v.tipo.equals("char")){
                                                                System.out.println("Asignacion: Variable "+i+", valor: "+v.getCharVal());
                                                        }
                                                }else{
                                                        System.err.println("Error en linea "+vleft+", columna "+vright+": Asignacion de "+v.tipo+" a variable de tipo "+sym.tipo);
                                                }
                                        }
                                }else{
                                        if(v.tipo.equals("notfound")){
                                                System.err.println("Error en linea "+vleft+", columna "+vright+": Variable no declarada en asignación");
                                        }if(v.tipo.equals("out of bounds")){
                                                System.err.println("Error en linea "+(vleft+1)+", columna "+vright+": Indice de arreglo esta fuera de alcance ");
                                        }else{
                                                System.err.println("Error en linea "+vleft+", columna "+vright+": Tipos incompatibles en operacion");
                                        }
                                }
                                
                        }else{
                                System.err.println("Error en linea "+vleft+", columna "+vright+": Asignación a variable no declarada");
                        }
                :};

ASIG2           ::= openBrk number:n closeBrk 
                                                {: 
                                                        if(Integer.parseInt(n)>=0){
                                                                RESULT = Integer.parseInt(n); 
                                                        }else{
                                                                RESULT = -2; 
                                                        } 
                                                :}
                | {: RESULT = -1; :};

//If
IF              ::= {: System.out.println("Inicio IF"); :} 
                ifstart parIzq COND parDer 
                ifthen EXP ELSIF endif 
                {: System.out.println("Fin if"); :};
ELSIF           ::= elseif parIzq COND parDer 
                {: System.out.println("\tCondicion elseif"); :} ifthen EXP ELSIF 
                | 
                ELSE;
ELSE            ::= elseclause ifthen 
                {: System.out.println("\tElse"); :} EXP 
                | ;

//While
WHILE           ::= 
                whilestart {: System.out.println("Inicio WHILE"); :}  parIzq COND parDer 
                {:System.out.println("\tCondicion while");:} 
                EXP end {: System.out.println("fin while"); :};

//Write
WRITE           ::= writestart parIzq VALS:val parDer 
                {:System.out.println("\tWRITE Valor:"+val);:};

//For
FOR             ::= 
                forstart {: //System.out.println("TABLA SIMBOLOS ANTES DE FOR: "+tabla.toString()); 
                :}
                parIzq 
                INIT:id pcoma {: //System.out.println("TABLA SIMBOLOS DESPUES DE VAR DE FOR: "+tabla.toString()); 
                :}
                COND pcoma 
                CONTADOR 
                parDer
                EXP
                end {: 
                        tabla.removeVar(id);  
                        //System.out.println("TABLA SIMBOLOS DESPUES DE FOR: "+tabla.toString()); 
                :};

CONTADOR        ::= 
                id:i contador:cont {:System.out.println("\t Contador: id: "+i+", contador: "+cont);:}; 

//Select
SELECT          ::= {: System.out.println("Inicio Select"); :}
                selectstart parIzq id:i parDer
                {:System.out.println("\tVariable:"+i);:}
                OPT
                end 
                {: System.out.println("fin select"); :};

OPT             ::= options VALS:v {: System.out.println("\t\tOpcion-valor: "+v); :} colon EXP breaks OPT2;
OPT2            ::= OPT | ;
        
//Condiciones negadas, normales, con OR o AND
// COND            ::= opNot COND2 
//                 |
//                 COND2 ;
// COND2           ::= id opRel COND3 
//                 | booleano
//                 |
//                 number opRel COND3;
// COND3           ::= id COND4 
//                 | booleano COND4
//                 |
//                 number COND4;
// COND4           ::= opOr COND 
//                 | 
//                 opAnd COND 
//                 | ;

COND ::= parIzq COND parDer COND2

        | opNot COND:c {: RESULT = new Expresion(); RESULT.listav = c.listaf; RESULT.listaf = c.listav; :} COND2

        | id:i1 opRel:opr id:i2 
                {:
                        int index_id1 = tabla.contains(i1);
                        int index_id2 = tabla.contains(i2);
                        if(index_id1 > -1 && index_id2 > -1){
                                System.out.println("Condicion: id "+i1+", op "+opr+", id "+i2); 
                                RESULT = new Expresion();
                                RESULT.listav.add(cuadruplos.size());
                                RESULT.listaf.add(cuadruplos.size()+1);
                                gen("IF"+opr, i1, i2, "");
                                gen("GOTO", "");
                        }else{
                                //error var(s) no encontrada(s)
                        }
                :} 
                COND2 

        | booleano:bo 
                {: 
                        RESULT = new Expresion();
                        if(bo.equals("true")){ 
                                RESULT.listav.add(cuadruplos.size()); 
                        }else{
                                RESULT.listaf.add(cuadruplos.size());
                        }
                        gen("GOTO", "");
                :} 
                COND2;

COND2 ::= opOr {: System.out.println("operador OR"); :} 
          M:m {: System.out.println("M.cuad: "+m.intValue()); :} COND
        | opAnd {: System.out.println("operador AND"); :} M:m {: System.out.println("M.cuad: "+m.intValue()); :} COND
        | {: System.out.println(""); :};

M ::= {: RESULT = new Integer(cuadruplos.size()); :} ;



// //Expresion Aritmetica
S               ::= E:e                 {: RESULT = e;:};

E               ::= E:e opSuma T:t      {: 
                                                if(e.tipo.equals("error") || t.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(e), y = operationValidation(t);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible types for operation");
                                                        }else{
                                                                RESULT = new Value("num", (Integer.parseInt(x) + Integer.parseInt(y))+"");
                                                        }
                                                }
                                        :}
                | 
                E:e opResta T:t         {: 
                                                if(e.tipo.equals("error") || t.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(e), y = operationValidation(t);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible types for operation");
                                                        }else{
                                                                //gen("-", e.val, t.val, nuevoTemp());
                                                                RESULT = new Value("num", (Integer.parseInt(x) - Integer.parseInt(y))+"");
                                                        }
                                                }                                                 
                                        :}
                | 
                T:t                     {:RESULT = t;:};

T               ::= T:t opMult F:f      {: 
                                                if(t.tipo.equals("error") || f.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(t), y = operationValidation(f);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible types for operation");
                                                        }else{
                                                                RESULT = new Value("num", (Integer.parseInt(x) * Integer.parseInt(y))+"");
                                                        }
                                                }  
                                        :}
                | 
                T:t opDiv F:f           {: 
                                                if(t.tipo.equals("error") || f.tipo.equals("error")){
                                                        RESULT = new Value("error", "notfound");
                                                }else{
                                                        String x = operationValidation(t), y = operationValidation(f);
                                                        if(x.equals("error") || y.equals("error")){
                                                                RESULT = new Value("error", "incompatible types for operation");
                                                        }else{
                                                                RESULT = new Value("num", (Integer.parseInt(x) / Integer.parseInt(y))+"");
                                                        }
                                                }  
                                        :}
                | 
                F:f                     {:RESULT=f;:};
                
F               ::=
                number:n                {:RESULT = new Value("num", n);:}
                |
                parIzq E:e parDer       {:RESULT = e;:}
                |
                 IdF:val         {:RESULT = val;:}
                ;


//Funcion con retorno
RETFUNC         ::= TIPO:t id:val {: calls.clear(); :} parIzq ARGS:args parDer
                cbOpen RETFUNCBODY {:
                        // boolean rec = false;
                        // for(int i = 0; i < calls.size(); i++){
                        //         if(calls.get(i).equals(val)){
                        //                 rec = true;
                        //                 break;
                        //         }
                        // }
                        // if(rec){
                        //         System.out.println("La funcion "+val+" es recursiva");
                        // }
                        int index = tabla.contains(val);
                        if(index >= 0){
                                Simbolo funcion = tabla.getSymbol(val);
                                if(funcion.tipo.equals(args+"->"+t)){
                                        System.out.println("Funcion "+val+", tipo: "+args+"->"+t);
                                }else{
                                        System.err.println("Error en linea "+argsleft+", columna "+argsright+": Funcion "+val+" definida como "+(args+"->"+t)+" pero fue declarada como "+funcion.tipo);
                                }
                        }else{
                                System.err.println("Error en linea "+valleft+", columna "+valright+": Funcion "+val+" no declarada");
                        }
                :} cbClose 
                ;
RETFUNCBODY     ::= EXP:exp ret RETVAL;
RETVAL          ::= VALS:retVal ;

//Funcion void
VOIDFUNC        ::= voidType id:val {:System.out.println("VOID FUNCTION "+val+" START"); calls.clear(); :} parIzq ARGS:args parDer
                cbOpen EXP {: 
                        // boolean rec = false;
                        // for(int i = 0; i < calls.size(); i++){
                        //         if(calls.get(i).equals(val)){
                        //                 rec = true;
                        //                 break;
                        //         }
                        // }
                        // if(rec){
                        //         System.out.println("La funcion "+val+" es recursiva");
                        // }
                        int index = tabla.contains(val);
                        if(index >= 0){
                                Simbolo funcion = tabla.getSymbol(val);
                                if(funcion.tipo.equals(args+"->void")){
                                        System.out.println("FIN FUNCTION");
                                }else{
                                        System.err.println("Error en linea "+argsleft+", columna "+argsright+": Funcion "+val+" definida como "+(args+"->void")+" pero fue declarada como "+funcion.tipo);
                                }
                        }else{
                                System.err.println("Error en linea "+valleft+", columna "+valright+": Funcion no declarada");
                        }
                :} cbClose ;


//Argumentos para funciones
ARGS            ::= TIPO:t id:i ARGS2:arg2       {: RESULT = t+arg2; :} 
                | ;
ARGS2           ::=  coma TIPO:t id:i ARGS2:arg2 {: RESULT = "x"+t+arg2; :}
        |                                        {: RESULT = ""; :};

//Tipos, falta array
TIPO            ::=
                TIPO:t openBrk closeBrk {: RESULT = t+" array"; :}
                |
                bool:val                {: RESULT = "bool"; :}
                |
                num:val                 {: RESULT = "num"; :}
                | 
                character:val           {: RESULT = "char"; :}
                ;

//Posibles valores que pueden haber: ids, numeros, booleans, strings/char (estos faltan)
VALS            ::=
                booleano:val    {: RESULT = new Value("bool", val); :}
                |
                charval:ch      {: RESULT = new Value("char", ch.charAt(1)+""); :}
                |
                S:val           {: RESULT = val; :}
                |
                ARRVAL0:val      {: RESULT = new Value("array", val); :}
                ;

//Valores para array
ARRVAL0          ::= cbOpen S:v ARRVAL2 cbClose 
                        {: 
                                arrayValue += v.val + "";
                                RESULT = arrayValue; 
                                arrayValue = ""; 
                        :}
                |cbOpen booleano:v ARRVAL2 cbClose 
                        {: 
                                arrayValue += v + "";
                                RESULT = arrayValue; 
                                arrayValue = ""; 
                        :}
                |cbOpen charval:v ARRVAL2 cbClose 
                        {: 
                                arrayValue += v + "";
                                RESULT = arrayValue; 
                                arrayValue = ""; 
                        :};        


ARRVAL2         ::= coma ARRVAL3:v
                |;

ARRVAL3         ::= S:v ARRVAL2       
                                        {:   
                                                arrayValue += (v.val+",");
                                        :}
                |booleano:v ARRVAL2   
                                        {:   
                                                arrayValue += (v+","); 
                                        :}
                |charval:v ARRVAL2    
                                        {:   
                                                arrayValue += (v+",");
                                        :};