package amuse;
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.List;

parser code {:
        public void report_error(String message,Object info){
                StringBuffer m=new StringBuffer("Error ");
                if(info instanceof Symbol){
                        Symbol s=((Symbol)info);

                        if(s.left>=0){
                                m.append("en linea "+(s.right));
                        if(s.right>=0)
                                m.append(", columna "+(s.left));
                        }
                }
                m.append(": "+message);
                System.err.println(m);
        }

        public void report_fatal_error(String message, Object info){
                report_error(message, info);
                System.exit(1);
        }

        public void unrecovered_syntax_error(Symbol cur_token){
                System.out.println(cur_token.toString());
                System.err.println("At line "+(cur_token.right)+", column "+cur_token.left);
                System.exit(1);
        }

        protected void report_expected_token_ids() {
	        List<Integer> ids = expected_token_ids();
	        LinkedList<String> list = new LinkedList<String>();
	        for (Integer expected : ids)
		        list.add(symbl_name_from_id(expected));
                System.err.println("Se esperaba: "+list);
	}
        
:};

action code
{:
:}

/**************
 * Terminales *
 **************/

//If
terminal String ifstart, ifthen, elseclause, elseif, endif;

//Estructura 
terminal String MainProgram, begin, end, parIzq, parDer, cbOpen, cbClose, ret, coma, pcoma;

//Tipos
terminal String booleano, id, voidType;

//Operadores
terminal String opRel, opArit, opOr, opAnd, opNot, opAsig;
terminal opSuma, opResta, opMult, opDiv;
terminal String number;

//Valores
terminal String bool, num, character;

//While                
terminal String whilestart;

//For                
terminal String forstart;

//Select             
terminal String selectstart, breaks, options, colon;

terminal String comment;


/*****************
 * No Terminales *
 *****************/

//Inicial y Expresion
non terminal START, EXP;

//If
non terminal IF, ELSIF, ELSE;

//While
non terminal WHILE;

//For
non terminal FOR;

//Select
non terminal SELECT, OPT;

//Condiciones multipes, negadas o normales
non terminal COND, COND2, COND3, COND4;

//Funcion con retorno
non terminal FUNC, RETFUNC, RETFUNC2, RETVAL;
non terminal String RETFUNCBODY;
//Funcion void
non terminal VOIDFUNC, VOIDFUNC2;

non terminal ARGS, ARGS2, ASIG;

non terminal String VALS, TIPO;

non terminal Integer E,T,F;
non terminal Integer S;

non terminal FunctionCall FCALL;
non terminal FCALLARGS, FCALLARGS2;
//Operadores
// non terminal Object EXP_ARIT, EXPRresp;
// non terminal Integer EXPS, FACT, TERM;


start with START;





START           ::= MainProgram parIzq parDer cbOpen {: System.out.println("Inicio main");:} EXP cbClose {: System.out.println("Fin main"); :} FUNC;

//No terminal para todas las expresiones que pueden haber. Aqui van ifs, for, switch, while, asignaciones, etc
EXP             ::= IF EXP:exp {: RESULT = exp; :}
                | WHILE EXP:exp {: RESULT = exp; :}
                | ASIG EXP:exp {: RESULT = exp; :}
                | error  EXP:exp {: RESULT = exp; :}
                | comment EXP:exp {: RESULT = exp; :}
                | FOR EXP:exp {: RESULT = exp; :}
                | SELECT EXP:exp {: RESULT = exp; :}
                | S EXP:exp {: RESULT = exp; :}
                | FCALL:val EXP {:RESULT = (FunctionCall)val; System.out.println("RESULT FCALL EXP: "+RESULT); :}
                | ;

FCALL ::= id:call {: RESULT = new FunctionCall(call); System.out.println("Llamado a funcion: "+call); System.out.println("Result: "+RESULT.call);:} parIzq FCALLARGS parDer;

FCALLARGS ::= VALS:arg FCALLARGS2 | ;
FCALLARGS2 ::= coma VALS:arg FCALLARGS2 | ; 

//No terminal que maneja todas las funciones despues del main
FUNC            ::= RETFUNC FUNC
                | VOIDFUNC FUNC
                | error FUNC 
                | ;

//Asignacion / Inicializacion
ASIG            ::= id:i TIPO:t opAsig VALS:v 
                {: System.out.println("\t Inicializacion: Tipo "+t+", id: "+i+", valor: "+v); :}
                |
                id:i opAsig VALS:v
                {: System.out.println("\t Asignacion:  id: "+i+", valor: "+v); :};

//If
IF              ::= {: System.out.println("Inicio IF"); :} 
                ifstart parIzq COND parDer 
                {: System.out.println("\tCondicion if"); :} 
                ifthen EXP ELSIF endif 
                {: System.out.println("Fin if"); :};
ELSIF           ::= elseif parIzq COND parDer 
                {: System.out.println("\tCondicion elseif"); :} ifthen EXP ELSIF 
                | 
                ELSE;
ELSE            ::= elseclause ifthen 
                {: System.out.println("\tElse"); :} EXP 
                | ;

//While
WHILE           ::= {: System.out.println("Inicio WHILE"); :} 
                whilestart parIzq COND parDer 
                {:System.out.println("\tCondicion while");:} 
                EXP end {: System.out.println("fin while"); :};

//For
FOR             ::= {: System.out.println("Inicio FOR"); :}
                forstart parIzq ASIG pcoma COND 
                {:System.out.println("\tCondicion for");:}
                pcoma COND parDer 
                {:System.out.println("\tCondicion for");:}
                EXP 
                end {: System.out.println("fin for"); :};

//Select
SELECT          ::= {: System.out.println("Inicio Select"); :}
                selectstart parIzq id:i parDer
                {:System.out.println("\tVariable:"+i);:}
                OPT
                end 
                {: System.out.println("fin select"); :};

OPT             ::= options VALS:v colon EXP breaks OPT
                {: System.out.println("\t\tOpcion-valor: "+v); :}
                | 
                options VALS:v colon EXP breaks
                {: System.out.println("\t\tOpcion-valor: "+v); :};
        
//Condiciones negadas, normales, con OR o AND
COND            ::= opNot COND2 
                |
                COND2 ;
COND2           ::= id opRel COND3 
                |
                number opRel COND3;
COND3           ::= id COND4 
                | 
                number COND4;
COND4           ::= opOr COND 
                | 
                opAnd COND 
                | ;

// //Expresion Aritmetica
S               ::= E:e {: RESULT = e;:};
E               ::= E:e opSuma T:t {: RESULT= new Integer(e.intValue()+t.intValue()); :}
                | 
                E:e opResta T:t {: RESULT = new Integer(e.intValue()-t.intValue()); :}
                | 
                T:t{:RESULT = t;:};
T               ::= T:t opMult F:f {: RESULT = new Integer(t.intValue() * f.intValue());:}
                | 
                T:t opDiv F:f {: RESULT = new Integer(t.intValue() / f.intValue());:}
                | 
                F:f {:RESULT=f;:};
F               ::= number:n {:RESULT = new Integer(n);:}
                |
                parIzq E:e parDer {:RESULT = e;:};


//Funcion con retorno
RETFUNC         ::= TIPO {:System.out.println("FUNCTION START");:} RETFUNC2;
RETFUNC2        ::= id:val parIzq ARGS {:System.out.println("\tArgumentos");:} parDer 
                cbOpen {: System.out.println("\tFUNCTION HEADER "); :} RETFUNCBODY:bodyval  cbClose 
                {:
                        if(!bodyval.equals("")){
                                if(bodyval.equals(val)){
                                        System.out.println("La funcion es recursiva");
                                }
                        } 
                        System.out.println("FIN FUNCTION");
                :};
RETFUNCBODY     ::= EXP:exp {: if(exp != null){ RESULT =((FunctionCall)exp).call+""; System.out.println(); }else{ RESULT = ""; }  :} ret {:System.out.print("\tRETURN - ");:} RETVAL;
RETVAL          ::= VALS:retVal {: System.out.println("Return value: "+retVal); :};

//Funcion void
VOIDFUNC        ::= voidType {:System.out.println("VOID FUNCTION START");:} VOIDFUNC2;
VOIDFUNC2       ::= id parIzq ARGS {:System.out.println("\tArgumentos");:} parDer
                cbOpen {: System.out.println("\tFUNCTION HEADER "); :} EXP cbClose {: System.out.println("FIN FUNCTION");:};


//Argumentos para funciones
ARGS            ::= TIPO id ARGS2 
                | ;
ARGS2           ::=  coma TIPO id ARGS2
                | ;

//Tipos, falta array
TIPO            ::= bool:val {: RESULT = "bool"; :}
                | 
                num:val {: RESULT = "num"; :}
                | 
                character:val {: RESULT = "char"; :};

//Posibles valores que pueden haber: ids, numeros, booleans, strings/char (estos faltan)
VALS            ::= id:val {: RESULT = val; :}
                | 
                booleano:val {: RESULT = val; :}
                |
                S:val {: RESULT = val.intValue() + ""; :}
                
                ;
                //| comilla letra:val{: System.out.println("val es:"+String.valueOf(val)); RESULT = String.valueOf(val); :} comilla;
